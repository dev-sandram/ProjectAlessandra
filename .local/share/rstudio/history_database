1761128497105:# ==========================================================
1761128497112:#' Summarize bulk RNA counts with metadata (data.table version)
1761128497116:#'
1761128497119:#' Merges bulk RNA-seq count data with sample metadata, filters treated samples
1761128497123:#' whose gene names start with "GENE_00", and computes mean/median counts per gene,
1761128497126:#' as well as per-condition mean counts.
1761128497129:#'
1761128497133:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128497136:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128497139:#' @return List with: filtered_data, gene_mean_median, gene_condition_means
1761128497143:#' \itemize{
1761128497145:#'   \item gene_mean_median: Mean and median counts by gene (treated only)
1761128497148:#'   \item gene_condition_means: Mean counts by gene and condition
1761128497152:#' }
1761128497154:#' @export
1761128497158:bulk_counts_summary_dt <- function(counts_path, meta_path) {
1761128497161:bulk_counts <- fread(counts_path)
1761128497165:sample_meta <- fread(meta_path)
1761128497170:setkey(bulk_counts, sample_id)
1761128497173:setkey(sample_meta, sample_id)
1761128497179:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128497185:filtered_data <- join_data[condition == "treated" & grepl("^GENE_00", gene)]
1761128497190:gene_mean_median <- filtered_data[, .(
1761128497193:mean_count   = mean(count),
1761128497196:median_count = median(count)
1761128497199:), by = gene]
1761128497206:gene_condition_means <- bulk_counts[
1761128497208:sample_meta,
1761128497211:on = "sample_id"
1761128497214:][ , .(
1761128497217:mean_count = mean(count)
1761128497221:), by = .(gene, condition) ]
1761128497229:return(list(filtered_data = filtered_data, gene_mean_median = gene_mean_median, gene_condition_means = gene_condition_means))
1761128497233:}
1761128497240:# ==========================================================
1761128497245:# ðŸ§© TASK 2 â€” QC-style derived columns
1761128497249:# ==========================================================
1761128497256:#' Add QC-style derived columns (data.table version)
1761128497260:#'
1761128497264:#' Adds log2-transformed counts and a binary \code{high} flag based on gene-wise medians.
1761128497268:#'
1761128497272:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128497277:#' @return Data.table with added columns: log2_count, high.
1761128497281:bulk_counts_qc_dt <- function(counts_path) {
1761128497285:counts <- fread(counts_path)
1761128497296:counts[, log2_count := log2(count)]
1761128497302:counts[, high := count > 100]
1761128497308:counts[, high := count > median(count), by = gene]
1761128497322:return(counts)
1761128497327:}
1761128497339:# ==========================================================
1761128497347:# ðŸ§© TASK 3 â€” Subset by gene and sample
1761128497353:# ==========================================================
1761128497363:#' Subset counts data using secondary index
1761128497366:#'
1761128497369:#' Joins metadata and subsets for a specific gene and sample using fast indexing.
1761128497372:#'
1761128497375:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128497378:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128497382:#' @param gene_name Gene name to subset
1761128497385:#' @param sample_chosen Sample ID to subset
1761128497388:#' @return Subset of counts for the given gene and sample.
1761128497391:#' @export
1761128497394:subset_counts_dt <- function(counts_path, meta_path, gene_call, sample_chosen) {
1761128497397:bulk_counts <- fread(counts_path)
1761128497400:sample_meta <- fread(meta_path)
1761128497406:setkey(sample_meta, sample_id)
1761128497414:join_data <- sample_meta[bulk_counts, on = "sample_id"]
1761128497421:time_no_index <- system.time({
1761128497424:subset_no_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128497427:})
1761128497434:setindex(bulk_counts, gene, sample_id)
1761128497441:time_with_index <- system.time({
1761128497445:subset_with_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128497452:})
1761128497465:dt_benchmark <- data.table(
1761128497470:test = c("time_no_index", "time_with_index"),
1761128497476:user = c(time_no_index["user.self"], time_with_index["user.self"]),
1761128497481:system = c(time_no_index["sys.self"], time_with_index["sys.self"]),
1761128497486:elapsed = c(time_no_index["elapsed"], time_with_index["elapsed"])
1761128497490:)
1761128497501:return(dt_benchmark)
1761128497510:}
1761128497534:# ==========================================================
1761128497547:# ðŸ§© TASK 4 â€” Annotate counts and summarize
1761128497557:# ==========================================================
1761128497581:#' Annotate counts with metadata and compute summaries
1761128497591:#'
1761128497605:#' Joins counts and metadata, computes per-patient total counts,
1761128497622:#' mean counts per gene and condition, and identifies top 10 genes.
1761128497638:#'
1761128497657:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128497670:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128497685:#' @return List with patient totals, and top10 genes.
1761128497692:annotate_counts_dt <- function(counts_path, meta_path) {
1761128497705:bulk_counts <- fread(counts_path)
1761128497712:sample_meta <- fread(meta_path)
1761128497736:setkey(bulk_counts, sample_id)
1761128497751:setkey(sample_meta, sample_id)
1761128497783:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128497829:patient_tot <- join_data[, .(total_count = sum(count)), by = patient_id]
1761128497845:gene_means <- join_data[, .(mean_count = mean(count)), by = .(gene, condition)]
1761128497885:top10 <- gene_means[
1761128497896:order(condition, -mean_count)
1761128497904:][, head(.SD, 10), by = condition]
1761128497918:return(list(patient_tot = patient_tot, top10 = top10))
1761128497924:}
1761128497937:# ==========================================================
1761128497944:# ðŸ§© TASK 5 â€” Classify lab values
1761128497951:# ==========================================================
1761128497964:#' Classify lab values against reference intervals
1761128497970:#'
1761128497976:#' Joins lab results and reference ranges, classifies as "normal" or "out_of_range",
1761128497982:#' and summarizes abnormalities per patient and per lab.
1761128497986:#'
1761128497991:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128497995:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761128498000:#' @return List with merged_labs, abnormal_by_patient, abnormal_by_lab.
1761128498006:classify_labs_dt <- function(labs_path, ref_path) {
1761128498016:labs <- fread(labs_path)
1761128498022:ref  <- fread(ref_path)
1761128498031:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761128498040:merged_labs <- merge(labs, ref_unique, by = "lab")
1761128498048:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761128498056:abnormal_by_patient <- merged_labs[, .(
1761128498060:total_tests = .N,
1761128498064:out_of_range = sum(status == "out_of_range")
1761128498068:), by = patient_id]
1761128498076:abnormal_by_lab <- merged_labs[, .(
1761128498079:total_tests = .N,
1761128498084:out_of_range = sum(status == "out_of_range")
1761128498088:), by = lab]
1761128498097:return(list(merged_labs = merged_labs, abnormal_by_patient = abnormal_by_patient, abnormal_by_lab = abnormal_by_lab))
1761128498101:}
1761128498109:# ==========================================================
1761128498113:# ðŸ§© TASK 6 â€” Match vitals to labs
1761128498124:# ==========================================================
1761128498135:#' Nearest-time matching of vitals and labs
1761128498139:#'
1761128498144:#' Matches nearest HR/SBP readings to each lab time and computes correlations.
1761128498147:#'
1761128498152:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128498156:#' @param vitals_path Path to CSV file with columns: time_iso
1761128498161:#' @return List with labs_with_vitals and correlations (CRP vs HR/SBP)
1761128498165:#' @export
1761128498169:match_vitals_dt <- function(labs_path, vitals_path) {
1761128498177:labs <- fread(labs_path)
1761128498180:vitals <- fread(vitals_path)
1761128498188:labs[, time_iso := as.POSIXct(time_iso)]
1761128498192:vitals[, time_iso := as.POSIXct(time_iso)]
1761128498203:setorder(labs, patient_id, time_iso)
1761128498211:setorder(vitals, patient_id, time_iso)
1761128498224:labs[, lab_time := time_iso]
1761128498227:setkey(labs, patient_id, time_iso)
1761128498232:setkey(vitals, patient_id, time_iso)
1761128498243:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)]
1761128498247:setnames(vitals_hr, "value", "nearest_HR")
1761128498254:vitals_hr[, hr_time := time_iso]
1761128498258:setkey(vitals_hr, patient_id, time_iso)
1761128498265:labs_with_hr <- vitals_hr[labs, roll = "nearest"]
1761128498273:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761128498289:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761128498292:setnames(vitals_sbp, "value", "nearest_SBP")
1761128498300:vitals_sbp[, sbp_time := time_iso]
1761128498306:setkey(vitals_sbp, patient_id, time_iso)
1761128498314:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761128498318:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761128498332:crp_data <- labs_with_vitals[lab == "CRP"]
1761128498347:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761128498354:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761128498361:), by = patient_id]
1761128498369:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761128498373:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761128498378:), by = patient_id]
1761128498388:return(list(labs_with_hr = labs_with_hr, labs_with_vitals=labs_with_vitals, cor_crp_hr = cor_hr, cor_crp_sbp = cor_sbp))
1761128498394:}
1761128498401:# ==========================================================
1761128498404:# ðŸ§© TASK 7 â€” Top peaks by score
1761128498409:# ==========================================================
1761128498416:#' Extract peaks on chromosome and return top N by score
1761128498420:#'
1761128498424:#' Filters by genomic region and selects top peaks by score.
1761128498428:#'
1761128498432:#' @param peaks_path Path to CSV file with columns:chr, start, end, peak_id, score
1761128498435:#' @param chr_sel selected chromosome string e.g.:"chr2"
1761128498439:#' @param start_min lower bound of range e.g.:2000000
1761128498442:#' @param start_max upper bound of range e.g.:4000000
1761128498446:#' @return Data.table of top peaks
1761128498451:#' @export
1761128498455:top_peaks_dt <- function(peaks_path, chr_path, start_min , start_max) {
1761128498462:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761128498470:subset_peaks <- peaks[chr == chr_sel & start >= start_min & start <= start_max]
1761128498478:subset_peaks <- setorder(subset_peaks, -score)
1761128498488:top50_peaks <- head(subset_peaks, 50)
1761128498497:return(top50_peaks)
1761128498500:}
1761128498509:# ==========================================================
1761128498515:# ðŸ§© TASK 8 â€” Gene stats and filtering
1761128498519:# ==========================================================
1761128498526:#' Per-condition robust summary stats and gene filtering
1761128498531:#'
1761128498535:#' Computes mean, median, quartiles by gene and condition,
1761128498539:#' filters genes with treated_mean â‰¥ 2 Ã— control_mean.
1761128498542:#'
1761128498546:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128498550:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128498555:#' @return List with stats_by_gene_condition and kept_genes
1761128498562:gene_stats_filter_dt <- function(counts_path, meta_path) {
1761128498566:counts <- fread(counts_path)
1761128498570:meta   <- fread(meta_path)
1761128498577:merged <- counts[meta, on = "sample_id"]
1761128498585:stats_by_gene_condition <- merged[, .(
1761128498589:mean_count   = mean(count),
1761128498593:median_count = median(count),
1761128498598:Q1           = quantile(count, 0.25, type = 2),
1761128498602:Q3           = quantile(count, 0.75, type = 2)
1761128498606:), by = .(gene, condition)]
1761128498614:treated_means <- stats_by_gene_condition[condition == "treated", .(gene, treated_mean = mean_count)]
1761128498619:control_means <- stats_by_gene_condition[condition == "control", .(gene, control_mean = mean_count)]
1761128498627:means_wide <- merge(treated_means, control_means, by = "gene", all = FALSE)
1761128498636:kept_genes <- means_wide[treated_mean >= 2 * control_mean]
1761128498645:return(list(stats_by_gene_condition = stats_by_gene_condition, kept_genes = kept_genes))
1761128498649:}
1761128498659:# ==========================================================
1761128498663:# ðŸ§© TASK 9 â€” Wide â†’ Long â†’ Wide
1761128498668:# ==========================================================
1761128498676:#' Convert wide counts to long and back, computing mean per condition
1761128498679:#'
1761128498684:#' @param counts_wide_path Path to CSV file with columns genes and samples
1761128498688:#' @return Data.table wide by condition with mean counts
1761128498696:wide_long_wide_dt <- function(counts_wide_path, meta_path) {
1761128498705:counts_wide <- fread(counts_wide_path)
1761128498713:counts_long <- melt(counts_wide, id.vars = "gene",
1761128498718:variable.name = "sample_id", value.name = "count")
1761128498726:meta <- fread(meta_path)
1761128498735:merged <- merge(counts_long, meta, by = "sample_id")
1761128498744:totals_per_sample <- merged[, .(total_count = sum(count)), by = sample_id]
1761128498752:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761128498761:gene_condition_means <- merged[, .(mean_count = mean(count)),
1761128498766:by = .(gene, condition)]
1761128498773:counts_condition_wide <- dcast(gene_condition_means,
1761128498777:gene ~ condition,
1761128498781:value.var = "mean_count")
1761128498784:return(counts_condition_wide)
1761128498789:}
1761128498797:# ==========================================================
1761128498801:# ðŸ§© TASK 10 â€” ATAC peaks to genes
1761128498805:# ==========================================================
1761128498814:#' Map ATAC peaks to genes and summarize overlaps
1761128498817:#'
1761128498825:#' Uses genomic overlap to assign peaks to genes and compute overlap statistics.
1761128498835:#'
1761128498853:#' @param peaks_path Path to CSV file with columns: chr, start, end, peak_id, score
1761128498870:#' @param genes_path Path to CSV file with columns: chr, start, end, gene
1761128498883:#' @return List with overlap tables, peaks_per_gene and top 20 genes by overlap
1761128498894:atac_to_gene_dt <- function(peaks_path, genes_path) {
1761128498903:peaks <- fread(peaks_path)
1761128498908:genes <- fread(genes_path)
1761128498916:setkey(peaks, chr, start, end)
1761128498920:setkey(genes, chr, start, end)
1761128498931:overlaps <- foverlaps(peaks, genes,
1761128498935:by.x = c("chr", "start", "end"),
1761128498939:by.y = c("chr", "start", "end"),
1761128498943:type = "any", nomatch = 0L)
1761128498952:overlaps[, overlap_bp := pmin(end, i.end) - pmax(start, i.start)]
1761128498960:overlaps <- overlaps[overlap_bp > 0]
1761128498968:peaks_per_gene <- overlaps[, .N, by = gene]
1761128498972:setnames(peaks_per_gene, "N", "num_peaks")
1761128498981:overlap_sum_per_gene <- overlaps[, .(total_overlap_bp = sum(overlap_bp)), by = gene]
1761128498989:top20_genes <- overlap_sum_per_gene[order(-total_overlap_bp)][1:20]
1761128498993:return(list(overlaps=overlaps, peaks_per_gene=peaks_per_gene, top20_genes=top20_genes))
1761128498999:}
1761128499008:# ==========================================================
1761128499012:# ðŸ§© TASK 11 â€” Variants to genes
1761128499016:# ==========================================================
1761128499024:#' Map genetic variants to genes and count HIGH-impact variants
1761128499029:#'
1761128499032:#' @param variants_path  Path to CSV file with columns: sample_id, chr, pos, ref, alt, impact
1761128499036:#' @param genes_path  Path to CSV file with columns: chr, start, end, gene
1761128499040:#' @return List with counts and high-impact genes
1761128499044:#' @export
1761128499048:variants_to_genes_dt <- function(variants_path, genes_path) {
1761128499056:variants <- fread(variants_path)
1761128499060:genes    <- fread(genes_path)
1761128499068:variants[, start := pos]  #creo per ogni variante un intervallo 1bp
1761128499072:variants[, end   := pos]  #foverlaps () lavora con intervalli start-end quindi gli servono
1761128499080:setkey(variants, chr, start, end)
1761128499088:setkey(genes,    chr, start, end)
1761128499096:overlaps <- foverlaps(variants, genes, type = "any", nomatch = 0L)
1761128499104:overlaps[, impact_upper := toupper(impact)]
1761128499112:high_overlaps <- overlaps[impact_upper == "HIGH"]
1761128499124:high_counts_by_gene_sample <- high_overlaps[, .(
1761128499129:high_variant_count = .N
1761128499133:), by = .(gene, sample_id)]
1761128499147:high_counts_by_gene <- high_overlaps[, .(
1761128499152:total_high_variants = .N
1761128499159:), by = gene][order(-total_high_variants)]
1761128499170:genes_with_high <- unique(high_counts_by_gene$gene)
1761128499176:return(list(overlaps=overlaps, genes_with_high = genes_with_high))
1761128499180:}
1761128499187:# ==========================================================
1761128499193:# ðŸ§© TASK 12 â€” Combine cohorts
1761128499196:# ==========================================================
1761128499204:#' Combine cohorts safely and compute per-cohort mean counts
1761128499208:#'
1761128499213:#' @param cohortA_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761128499217:#' @param cohortB_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761128499221:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128499225:#' @return List with combined cohort info and top genes
1761128499232:combine_cohorts_dt <- function(cohortA_path, cohortB_path, counts_path) {
1761128499240:cohortA <- fread(cohortA_path)
1761128499244:cohortB <- fread(cohortB_path)
1761128499248:counts  <- fread(counts_path)
1761128499256:cohortA[, cohort := "A"]
1761128499259:cohortB[, cohort := "B"]
1761128499267:combined_cohorts <- rbindlist(list(cohortA, cohortB), use.names = TRUE, fill = TRUE)
1761128499274:setorder(combined_cohorts, cohort, condition, sample_id)
1761128499282:merged_per_sampleid <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761128499289:gene_variance <- merged_per_sampleid[, .(variance = var(count, na.rm = TRUE)), by = gene]
1761128499299:top100_genes <- gene_variance[order(-variance)][1:100, gene]
1761128499306:top100_data <- merged_per_sampleid[gene %in% top100_genes]
1761128499314:mean_counts <- top100_data[, .(
1761128499318:mean_count = mean(count, na.rm = TRUE)
1761128499322:), by = .(gene, cohort, condition)]
1761128499330:return(top100_data)
1761128499334:}
1761128513314:devtools::document()
1761128518511:devtools::load_all()
1761128549386:library(data.table)
1761128549842:#' as well as per-condition mean counts.
1761128549851:#'
1761128549857:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128549864:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128549876:#' @return List with: filtered_data, gene_mean_median, gene_condition_means
1761128549883:#' \itemize{
1761128549888:#'   \item gene_mean_median: Mean and median counts by gene (treated only)
1761128549892:#'   \item gene_condition_means: Mean counts by gene and condition
1761128549897:#' }
1761128549904:#' @export
1761128549910:bulk_counts_summary_dt <- function(counts_path, meta_path) {
1761128549915:bulk_counts <- fread(counts_path)
1761128549920:sample_meta <- fread(meta_path)
1761128549929:setkey(bulk_counts, sample_id)
1761128549933:setkey(sample_meta, sample_id)
1761128549941:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128549949:filtered_data <- join_data[condition == "treated" & grepl("^GENE_00", gene)]
1761128549957:gene_mean_median <- filtered_data[, .(
1761128549961:mean_count   = mean(count),
1761128549965:median_count = median(count)
1761128549970:), by = gene]
1761128549978:gene_condition_means <- bulk_counts[
1761128549981:sample_meta,
1761128549986:on = "sample_id"
1761128549991:][ , .(
1761128549996:mean_count = mean(count)
1761128550004:), by = .(gene, condition) ]
1761128550016:return(list(filtered_data = filtered_data, gene_mean_median = gene_mean_median, gene_condition_means = gene_condition_means))
1761128550021:}
1761128550033:#' Add QC-style derived columns (data.table version)
1761128550043:#'
1761128550047:#' Adds log2-transformed counts and a binary \code{high} flag based on gene-wise medians.
1761128550052:#'
1761128550057:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128550063:#' @return Data.table with added columns: log2_count, high.
1761128550068:bulk_counts_qc_dt <- function(counts_path) {
1761128550072:counts <- fread(counts_path)
1761128550077:counts[, log2_count := log2(count)]
1761128550081:counts[, high := count > 100]
1761128550086:counts[, high := count > median(count), by = gene]
1761128550094:return(counts)
1761128550098:}
1761128550740:#' Subset counts data using secondary index
1761128550764:#'
1761128550809:#' Joins metadata and subsets for a specific gene and sample using fast indexing.
1761128550824:#'
1761128550832:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128550846:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128550873:#' @param gene_name Gene name to subset
1761128550885:#' @param sample_chosen Sample ID to subset
1761128550913:#' @return Subset of counts for the given gene and sample.
1761128550927:#' @export
1761128550936:subset_counts_dt <- function(counts_path, meta_path, gene_call, sample_chosen) {
1761128550943:bulk_counts <- fread(counts_path)
1761128550948:sample_meta <- fread(meta_path)
1761128550962:setkey(sample_meta, sample_id)
1761128550982:join_data <- sample_meta[bulk_counts, on = "sample_id"]
1761128550990:time_no_index <- system.time({
1761128550995:subset_no_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128550999:})
1761128551008:setindex(bulk_counts, gene, sample_id)
1761128551017:time_with_index <- system.time({
1761128551022:subset_with_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128551025:})
1761128551034:dt_benchmark <- data.table(
1761128551039:test = c("time_no_index", "time_with_index"),
1761128551043:user = c(time_no_index["user.self"], time_with_index["user.self"]),
1761128551048:system = c(time_no_index["sys.self"], time_with_index["sys.self"]),
1761128551052:elapsed = c(time_no_index["elapsed"], time_with_index["elapsed"])
1761128551056:)
1761128551065:return(dt_benchmark)
1761128551070:}
1761128551076:#' Annotate counts with metadata and compute summaries
1761128551080:#'
1761128551084:#' Joins counts and metadata, computes per-patient total counts,
1761128551088:#' mean counts per gene and condition, and identifies top 10 genes.
1761128551093:#'
1761128551097:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128551106:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128551115:#' @return List with patient totals, and top10 genes.
1761128551125:annotate_counts_dt <- function(counts_path, meta_path) {
1761128551140:bulk_counts <- fread(counts_path)
1761128551152:sample_meta <- fread(meta_path)
1761128551193:setkey(bulk_counts, sample_id)
1761128551201:setkey(sample_meta, sample_id)
1761128551213:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128551244:patient_tot <- join_data[, .(total_count = sum(count)), by = patient_id]
1761128551265:gene_means <- join_data[, .(mean_count = mean(count)), by = .(gene, condition)]
1761128551296:top10 <- gene_means[
1761128551302:order(condition, -mean_count)
1761128551317:][, head(.SD, 10), by = condition]
1761128551331:return(list(patient_tot = patient_tot, top10 = top10))
1761128551336:}
1761128551344:#' Classify lab values against reference intervals
1761128551349:#'
1761128551356:#' Joins lab results and reference ranges, classifies as "normal" or "out_of_range",
1761128551366:#' and summarizes abnormalities per patient and per lab.
1761128551375:#'
1761128551383:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128551389:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761128551394:#' @return List with merged_labs, abnormal_by_patient, abnormal_by_lab.
1761128551398:classify_labs_dt <- function(labs_path, ref_path) {
1761128551409:labs <- fread(labs_path)
1761128551415:ref  <- fread(ref_path)
1761128551426:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761128551435:merged_labs <- merge(labs, ref_unique, by = "lab")
1761128551443:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761128551453:abnormal_by_patient <- merged_labs[, .(
1761128551457:total_tests = .N,
1761128551461:out_of_range = sum(status == "out_of_range")
1761128551466:), by = patient_id]
1761128551476:abnormal_by_lab <- merged_labs[, .(
1761128551481:total_tests = .N,
1761128551486:out_of_range = sum(status == "out_of_range")
1761128551490:), by = lab]
1761128551500:return(list(merged_labs = merged_labs, abnormal_by_patient = abnormal_by_patient, abnormal_by_lab = abnormal_by_lab))
1761128551507:}
1761128551517:#' Nearest-time matching of vitals and labs
1761128551522:#'
1761128551527:#' Matches nearest HR/SBP readings to each lab time and computes correlations.
1761128551532:#'
1761128551538:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128551543:#' @param vitals_path Path to CSV file with columns: time_iso
1761128551548:#' @return List with labs_with_vitals and correlations (CRP vs HR/SBP)
1761128551552:#' @export
1761128551557:match_vitals_dt <- function(labs_path, vitals_path) {
1761128551565:labs <- fread(labs_path)
1761128551571:vitals <- fread(vitals_path)
1761128551581:labs[, time_iso := as.POSIXct(time_iso)]
1761128551586:vitals[, time_iso := as.POSIXct(time_iso)]
1761128551594:setorder(labs, patient_id, time_iso)
1761128551599:setorder(vitals, patient_id, time_iso)
1761128551612:labs[, lab_time := time_iso]
1761128551616:setkey(labs, patient_id, time_iso)
1761128551622:setkey(vitals, patient_id, time_iso)
1761128551634:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)]
1761128551642:setnames(vitals_hr, "value", "nearest_HR")
1761128551658:vitals_hr[, hr_time := time_iso]
1761128551662:setkey(vitals_hr, patient_id, time_iso)
1761128551671:labs_with_hr <- vitals_hr[labs, roll = "nearest"]
1761128551684:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761128551709:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761128551714:setnames(vitals_sbp, "value", "nearest_SBP")
1761128551726:vitals_sbp[, sbp_time := time_iso]
1761128551731:setkey(vitals_sbp, patient_id, time_iso)
1761128551740:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761128551744:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761128551757:crp_data <- labs_with_vitals[lab == "CRP"]
1761128551770:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761128551776:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761128551780:), by = patient_id]
1761128551793:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761128551798:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761128551807:), by = patient_id]
1761128551820:return(list(labs_with_hr = labs_with_hr, labs_with_vitals=labs_with_vitals, cor_crp_hr = cor_hr, cor_crp_sbp = cor_sbp))
1761128551828:}
1761128551841:#' Extract peaks on chromosome and return top N by score
1761128551846:#'
1761128551850:#' Filters by genomic region and selects top peaks by score.
1761128551854:#'
1761128551858:#' @param peaks_path Path to CSV file with columns:chr, start, end, peak_id, score
1761128551864:#' @param chr_sel selected chromosome string e.g.:"chr2"
1761128551870:#' @param start_min lower bound of range e.g.:2000000
1761128551875:#' @param start_max upper bound of range e.g.:4000000
1761128551881:#' @return Data.table of top peaks
1761128551886:#' @export
1761128551890:top_peaks_dt <- function(peaks_path, chr_path, start_min , start_max) {
1761128551899:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761128551908:subset_peaks <- peaks[chr == chr_sel & start >= start_min & start <= start_max]
1761128551917:subset_peaks <- setorder(subset_peaks, -score)
1761128551929:top50_peaks <- head(subset_peaks, 50)
1761128551937:return(top50_peaks)
1761128551942:}
1761128551948:gene_stats_filter_dt <- function(counts_path, meta_path) {
1761128551954:counts <- fread(counts_path)
1761128551961:meta   <- fread(meta_path)
1761128551976:merged <- counts[meta, on = "sample_id"]
1761128551990:stats_by_gene_condition <- merged[, .(
1761128551995:mean_count   = mean(count),
1761128552004:median_count = median(count),
1761128552015:Q1           = quantile(count, 0.25, type = 2),
1761128552023:Q3           = quantile(count, 0.75, type = 2)
1761128552028:), by = .(gene, condition)]
1761128552039:treated_means <- stats_by_gene_condition[condition == "treated", .(gene, treated_mean = mean_count)]
1761128552045:control_means <- stats_by_gene_condition[condition == "control", .(gene, control_mean = mean_count)]
1761128552055:means_wide <- merge(treated_means, control_means, by = "gene", all = FALSE)
1761128552064:kept_genes <- means_wide[treated_mean >= 2 * control_mean]
1761128552072:return(list(stats_by_gene_condition = stats_by_gene_condition, kept_genes = kept_genes))
1761128552076:}
1761128552082:wide_long_wide_dt <- function(counts_wide_path, meta_path) {
1761128552091:counts_wide <- fread(counts_wide_path)
1761128552099:counts_long <- melt(counts_wide, id.vars = "gene",
1761128552104:variable.name = "sample_id", value.name = "count")
1761128552113:meta <- fread(meta_path)
1761128552124:merged <- merge(counts_long, meta, by = "sample_id")
1761128552137:totals_per_sample <- merged[, .(total_count = sum(count)), by = sample_id]
1761128552149:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761128552164:gene_condition_means <- merged[, .(mean_count = mean(count)),
1761128552174:by = .(gene, condition)]
1761128552188:counts_condition_wide <- dcast(gene_condition_means,
1761128552193:gene ~ condition,
1761128552199:value.var = "mean_count")
1761128552204:return(counts_condition_wide)
1761128552209:}
1761128552215:atac_to_gene_dt <- function(peaks_path, genes_path) {
1761128552224:peaks <- fread(peaks_path)
1761128552228:genes <- fread(genes_path)
1761128552237:setkey(peaks, chr, start, end)
1761128552242:setkey(genes, chr, start, end)
1761128552250:overlaps <- foverlaps(peaks, genes,
1761128552255:by.x = c("chr", "start", "end"),
1761128552259:by.y = c("chr", "start", "end"),
1761128552264:type = "any", nomatch = 0L)
1761128552273:overlaps[, overlap_bp := pmin(end, i.end) - pmax(start, i.start)]
1761128552284:overlaps <- overlaps[overlap_bp > 0]
1761128552299:peaks_per_gene <- overlaps[, .N, by = gene]
1761128552304:setnames(peaks_per_gene, "N", "num_peaks")
1761128552315:overlap_sum_per_gene <- overlaps[, .(total_overlap_bp = sum(overlap_bp)), by = gene]
1761128552337:top20_genes <- overlap_sum_per_gene[order(-total_overlap_bp)][1:20]
1761128552343:return(list(overlaps=overlaps, peaks_per_gene=peaks_per_gene, top20_genes=top20_genes))
1761128552348:}
1761128552355:#' Map genetic variants to genes and count HIGH-impact variants
1761128552362:#'
1761128552366:#' @param variants_path  Path to CSV file with columns: sample_id, chr, pos, ref, alt, impact
1761128552372:#' @param genes_path  Path to CSV file with columns: chr, start, end, gene
1761128552377:#' @return List with counts and high-impact genes
1761128552383:#' @export
1761128552388:variants_to_genes_dt <- function(variants_path, genes_path) {
1761128552397:variants <- fread(variants_path)
1761128552401:genes    <- fread(genes_path)
1761128552410:variants[, start := pos]  #creo per ogni variante un intervallo 1bp
1761128552414:variants[, end   := pos]  #foverlaps () lavora con intervalli start-end quindi gli servono
1761128552422:setkey(variants, chr, start, end)
1761128552427:setkey(genes,    chr, start, end)
1761128552436:overlaps <- foverlaps(variants, genes, type = "any", nomatch = 0L)
1761128552444:overlaps[, impact_upper := toupper(impact)]
1761128552455:high_overlaps <- overlaps[impact_upper == "HIGH"]
1761128552469:high_counts_by_gene_sample <- high_overlaps[, .(
1761128552477:high_variant_count = .N
1761128552483:), by = .(gene, sample_id)]
1761128552501:high_counts_by_gene <- high_overlaps[, .(
1761128552511:total_high_variants = .N
1761128552517:), by = gene][order(-total_high_variants)]
1761128552532:genes_with_high <- unique(high_counts_by_gene$gene)
1761128552538:return(list(overlaps=overlaps, genes_with_high = genes_with_high))
1761128552543:}
1761128552550:combine_cohorts_dt <- function(cohortA_path, cohortB_path, counts_path) {
1761128552559:cohortA <- fread(cohortA_path)
1761128552563:cohortB <- fread(cohortB_path)
1761128552568:counts  <- fread(counts_path)
1761128552577:cohortA[, cohort := "A"]
1761128552583:cohortB[, cohort := "B"]
1761128552592:combined_cohorts <- rbindlist(list(cohortA, cohortB), use.names = TRUE, fill = TRUE)
1761128552601:setorder(combined_cohorts, cohort, condition, sample_id)
1761128552610:merged_per_sampleid <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761128552619:gene_variance <- merged_per_sampleid[, .(variance = var(count, na.rm = TRUE)), by = gene]
1761128552632:top100_genes <- gene_variance[order(-variance)][1:100, gene]
1761128552648:top100_data <- merged_per_sampleid[gene %in% top100_genes]
1761128552661:mean_counts <- top100_data[, .(
1761128552670:mean_count = mean(count, na.rm = TRUE)
1761128552676:), by = .(gene, cohort, condition)]
1761128552689:return(top100_data)
1761128552695:}
1761128552702:#' Combine integration and clustering data
1761128552707:#'
1761128552712:#' Reads and merges integration and clustering tables by cell ID, ensuring consistent ID formatting.
1761128552716:#'
1761128552721:#' @export
1761128552725:combine_integration_clustering_dt <- function(integration_file, clustering_file) {
1761128552730:int <- fread(integration_file)
1761128552735:clu <- fread(clustering_file)
1761128552739:normalize <- function(x) gsub("_X_|_Y_", "_", trimws(as.character(x)))
1761128552744:int[, cell_clean := normalize(cell)]
1761128552749:clu[, cell_clean := normalize(cell)]
1761128552753:merge(int, clu, by = "cell_clean", all = FALSE)
1761128552758:}
1761128552763:#' Count cells per cluster and cell type
1761128552768:#' @export
1761128552773:count_cells_per_cluster_dt <- function(combined_dt) {
1761128552777:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type)]
1761128552784:setnames(counts, "N", "cell_count")
1761128552789:counts
1761128552796:}
1761128552805:#' Count cells per cluster, cell type, and sample type
1761128552814:#' @export
1761128552823:add_sample_type_dt <- function(combined_dt) {
1761128552829:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type, sample_type)]
1761128552834:setnames(counts, "N", "cell_count")
1761128552840:counts
1761128552846:}
1761128552852:#' Compute total cell counts per cluster and sample type
1761128552856:#' @export
1761128552862:compute_totals_dt <- function(counts_dt) {
1761128552866:counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761128552871:}
1761128552878:#' Compute normalized percentages per cluster and tissue
1761128552882:#' @export
1761128552887:compute_percentages_dt <- function(counts_dt) {
1761128552892:totals <- counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761128552896:merged <- merge(counts_dt, totals, by = c("integration_cluster", "sample_type"))
1761128552901:merged[, percent := round((cell_count / total_cells) * 100, 2)]
1761128552906:merged[order(integration_cluster)]
1761128552911:}
1761128571775:devtools::document()
1761128577031:devtools::load_all()
1761128757005:library(data.table)
1761128757023:# ==========================================================
1761128757028:# ðŸ§© TASK 1 â€” Bulk RNA counts summary
1761128757034:# ==========================================================
1761128757044:#' Summarize bulk RNA counts with metadata (data.table version)
1761128757049:#'
1761128757053:#' Merges bulk RNA-seq count data with sample metadata, filters treated samples
1761128757058:#' whose gene names start with "GENE_00", and computes mean/median counts per gene,
1761128757062:#' as well as per-condition mean counts.
1761128757066:#'
1761128757071:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128757075:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128757079:#' @return List with: filtered_data, gene_mean_median, gene_condition_means
1761128757084:#' \itemize{
1761128757088:#'   \item gene_mean_median: Mean and median counts by gene (treated only)
1761128757092:#'   \item gene_condition_means: Mean counts by gene and condition
1761128757096:#' }
1761128757100:#' @export
1761128757105:bulk_counts_summary_dt <- function(counts_path, meta_path) {
1761128757109:bulk_counts <- fread(counts_path)
1761128757113:sample_meta <- fread(meta_path)
1761128757121:setkey(bulk_counts, sample_id)
1761128757125:setkey(sample_meta, sample_id)
1761128757133:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128757142:filtered_data <- join_data[condition == "treated" & grepl("^GENE_00", gene)]
1761128757150:gene_mean_median <- filtered_data[, .(
1761128757155:mean_count   = mean(count),
1761128757159:median_count = median(count)
1761128757163:), by = gene]
1761128757172:gene_condition_means <- bulk_counts[
1761128757176:sample_meta,
1761128757180:on = "sample_id"
1761128757184:][ , .(
1761128757188:mean_count = mean(count)
1761128757192:), by = .(gene, condition) ]
1761128757201:return(list(filtered_data = filtered_data, gene_mean_median = gene_mean_median, gene_condition_means = gene_condition_means))
1761128757205:}
1761128757213:# ==========================================================
1761128757217:# ðŸ§© TASK 2 â€” QC-style derived columns
1761128757221:# ==========================================================
1761128757229:#' Add QC-style derived columns (data.table version)
1761128757234:#'
1761128757238:#' Adds log2-transformed counts and a binary \code{high} flag based on gene-wise medians.
1761128757242:#'
1761128757246:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128757251:#' @return Data.table with added columns: log2_count, high.
1761128757255:#' @export
1761128757259:bulk_counts_qc_dt <- function(counts_path) {
1761128757263:counts <- fread(counts_path)
1761128757267:counts[, log2_count := log2(count)]
1761128757272:counts[, high := count > 100]
1761128757276:counts[, high := count > median(count), by = gene]
1761128757284:return(counts)
1761128757288:}
1761128757297:# ==========================================================
1761128757302:# ðŸ§© TASK 3 â€” Subset by gene and sample
1761128757306:# ==========================================================
1761128757317:#' Subset counts data using secondary index
1761128757321:#'
1761128757326:#' Joins metadata and subsets for a specific gene and sample using fast indexing.
1761128757330:#'
1761128757336:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128757343:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128757348:#' @param gene_name Gene name to subset
1761128757354:#' @param sample_chosen Sample ID to subset
1761128757360:#' @return Subset of counts for the given gene and sample.
1761128757366:#' @export
1761128757372:subset_counts_dt <- function(counts_path, meta_path, gene_call, sample_chosen) {
1761128757378:bulk_counts <- fread(counts_path)
1761128757385:sample_meta <- fread(meta_path)
1761128757397:setkey(sample_meta, sample_id)
1761128757405:join_data <- sample_meta[bulk_counts, on = "sample_id"]
1761128757417:time_no_index <- system.time({
1761128757425:subset_no_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128757432:})
1761128757452:setindex(bulk_counts, gene, sample_id)
1761128757469:time_with_index <- system.time({
1761128757476:subset_with_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128757484:})
1761128757499:dt_benchmark <- data.table(
1761128757506:test = c("time_no_index", "time_with_index"),
1761128757512:user = c(time_no_index["user.self"], time_with_index["user.self"]),
1761128757520:system = c(time_no_index["sys.self"], time_with_index["sys.self"]),
1761128757525:elapsed = c(time_no_index["elapsed"], time_with_index["elapsed"])
1761128757532:)
1761128757547:return(dt_benchmark)
1761128757553:}
1761128757566:# ==========================================================
1761128757573:# ðŸ§© TASK 4 â€” Annotate counts and summarize
1761128757580:# ==========================================================
1761128757591:#' Annotate counts with metadata and compute summaries
1761128757596:#'
1761128757601:#' Joins counts and metadata, computes per-patient total counts,
1761128757606:#' mean counts per gene and condition, and identifies top 10 genes.
1761128757610:#'
1761128757615:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128757620:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128757624:#' @return List with patient totals, and top10 genes.
1761128757629:#' @export
1761128757634:annotate_counts_dt <- function(counts_path, meta_path) {
1761128757643:bulk_counts <- fread(counts_path)
1761128757647:sample_meta <- fread(meta_path)
1761128757660:setkey(bulk_counts, sample_id)
1761128757665:setkey(sample_meta, sample_id)
1761128757669:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128757681:patient_tot <- join_data[, .(total_count = sum(count)), by = patient_id]
1761128757695:gene_means <- join_data[, .(mean_count = mean(count)), by = .(gene, condition)]
1761128757708:top10 <- gene_means[
1761128757713:order(condition, -mean_count)
1761128757717:][, head(.SD, 10), by = condition]
1761128757726:return(list(patient_tot = patient_tot, top10 = top10))
1761128757730:}
1761128757739:# ==========================================================
1761128757743:# ðŸ§© TASK 5 â€” Classify lab values
1761128757748:# ==========================================================
1761128757758:#' Classify lab values against reference intervals
1761128757762:#'
1761128757767:#' Joins lab results and reference ranges, classifies as "normal" or "out_of_range",
1761128757772:#' and summarizes abnormalities per patient and per lab.
1761128757777:#'
1761128757781:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128757786:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761128757791:#' @return List with merged_labs, abnormal_by_patient, abnormal_by_lab.
1761128757797:#' @export
1761128757804:classify_labs_dt <- function(labs_path, ref_path) {
1761128757815:labs <- fread(labs_path)
1761128757821:ref  <- fread(ref_path)
1761128757832:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761128757845:merged_labs <- merge(labs, ref_unique, by = "lab")
1761128757856:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761128757868:abnormal_by_patient <- merged_labs[, .(
1761128757873:total_tests = .N,
1761128757879:out_of_range = sum(status == "out_of_range")
1761128757886:), by = patient_id]
1761128757898:abnormal_by_lab <- merged_labs[, .(
1761128757904:total_tests = .N,
1761128757910:out_of_range = sum(status == "out_of_range")
1761128757917:), by = lab]
1761128757928:return(list(merged_labs = merged_labs, abnormal_by_patient = abnormal_by_patient, abnormal_by_lab = abnormal_by_lab))
1761128757934:}
1761128757946:# ==========================================================
1761128757952:# ðŸ§© TASK 6 â€” Match vitals to labs
1761128757959:# ==========================================================
1761128757969:#' Nearest-time matching of vitals and labs
1761128757976:#'
1761128757982:#' Matches nearest HR/SBP readings to each lab time and computes correlations.
1761128757987:#'
1761128757993:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128758000:#' @param vitals_path Path to CSV file with columns: time_iso
1761128758006:#' @return List with labs_with_vitals and correlations (CRP vs HR/SBP)
1761128758014:#' @export
1761128758022:match_vitals_dt <- function(labs_path, vitals_path) {
1761128758032:labs <- fread(labs_path)
1761128758037:vitals <- fread(vitals_path)
1761128758047:labs[, time_iso := as.POSIXct(time_iso)]
1761128758052:vitals[, time_iso := as.POSIXct(time_iso)]
1761128758062:setorder(labs, patient_id, time_iso)
1761128758068:setorder(vitals, patient_id, time_iso)
1761128758082:labs[, lab_time := time_iso]
1761128758087:setkey(labs, patient_id, time_iso)
1761128758092:setkey(vitals, patient_id, time_iso)
1761128758105:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)]
1761128758109:setnames(vitals_hr, "value", "nearest_HR")
1761128758118:vitals_hr[, hr_time := time_iso]
1761128758122:setkey(vitals_hr, patient_id, time_iso)
1761128758131:labs_with_hr <- vitals_hr[labs, roll = "nearest"]
1761128758140:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761128758149:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761128758153:setnames(vitals_sbp, "value", "nearest_SBP")
1761128758162:vitals_sbp[, sbp_time := time_iso]
1761128758166:setkey(vitals_sbp, patient_id, time_iso)
1761128758176:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761128758181:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761128758196:crp_data <- labs_with_vitals[lab == "CRP"]
1761128758212:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761128758217:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761128758222:), by = patient_id]
1761128758232:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761128758240:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761128758244:), by = patient_id]
1761128758257:return(list(labs_with_hr = labs_with_hr, labs_with_vitals=labs_with_vitals, cor_crp_hr = cor_hr, cor_crp_sbp = cor_sbp))
1761128758263:}
1761128758274:# ==========================================================
1761128758281:# ðŸ§© TASK 7 â€” Top peaks by score
1761128758286:# ==========================================================
1761128758298:#' Extract peaks on chromosome and return top N by score
1761128758304:#'
1761128758310:#' Filters by genomic region and selects top peaks by score.
1761128758315:#'
1761128758322:#' @param peaks_path Path to CSV file with columns:chr, start, end, peak_id, score
1761128758328:#' @param chr_sel selected chromosome string e.g.:"chr2"
1761128758333:#' @param start_min lower bound of range e.g.:2000000
1761128758339:#' @param start_max upper bound of range e.g.:4000000
1761128758346:#' @return Data.table of top peaks
1761128758352:#' @export
1761128758357:top_peaks_dt <- function(peaks_path, chr_path, start_min , start_max) {
1761128758370:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761128758381:subset_peaks <- peaks[chr == chr_sel & start >= start_min & start <= start_max]
1761128758390:subset_peaks <- setorder(subset_peaks, -score)
1761128758400:top50_peaks <- head(subset_peaks, 50)
1761128758409:return(top50_peaks)
1761128758413:}
1761128758425:# ==========================================================
1761128758431:# ðŸ§© TASK 8 â€” Gene stats and filtering
1761128758436:# ==========================================================
1761128758448:#' Per-condition robust summary stats and gene filtering
1761128758453:#'
1761128758460:#' Computes mean, median, quartiles by gene and condition,
1761128758468:#' filters genes with treated_mean â‰¥ 2 Ã— control_mean.
1761128758473:#'
1761128758479:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128758485:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128758491:#' @return List with stats_by_gene_condition and kept_genes
1761128758497:#' @export
1761128758513:gene_stats_filter_dt <- function(counts_path, meta_path) {
1761128758520:counts <- fread(counts_path)
1761128758526:meta   <- fread(meta_path)
1761128758537:merged <- counts[meta, on = "sample_id"]
1761128758548:stats_by_gene_condition <- merged[, .(
1761128758553:mean_count   = mean(count),
1761128758559:median_count = median(count),
1761128758565:Q1           = quantile(count, 0.25, type = 2),
1761128758571:Q3           = quantile(count, 0.75, type = 2)
1761128758576:), by = .(gene, condition)]
1761128758587:treated_means <- stats_by_gene_condition[condition == "treated", .(gene, treated_mean = mean_count)]
1761128758592:control_means <- stats_by_gene_condition[condition == "control", .(gene, control_mean = mean_count)]
1761128758605:means_wide <- merge(treated_means, control_means, by = "gene", all = FALSE)
1761128758618:kept_genes <- means_wide[treated_mean >= 2 * control_mean]
1761128758630:return(list(stats_by_gene_condition = stats_by_gene_condition, kept_genes = kept_genes))
1761128758636:}
1761128758650:# ==========================================================
1761128758655:# ðŸ§© TASK 9 â€” Wide â†’ Long â†’ Wide
1761128758661:# ==========================================================
1761128758676:#' Convert wide counts to long and back, computing mean per condition
1761128758683:#'
1761128758689:#' @param counts_wide_path Path to CSV file with columns genes and samples
1761128758694:#' @return Data.table wide by condition with mean counts
1761128758701:#' @export
1761128758715:wide_long_wide_dt <- function(counts_wide_path, meta_path) {
1761128758729:counts_wide <- fread(counts_wide_path)
1761128758742:counts_long <- melt(counts_wide, id.vars = "gene",
1761128758748:variable.name = "sample_id", value.name = "count")
1761128758761:meta <- fread(meta_path)
1761128758774:merged <- merge(counts_long, meta, by = "sample_id")
1761128758787:totals_per_sample <- merged[, .(total_count = sum(count)), by = sample_id]
1761128758798:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761128758812:gene_condition_means <- merged[, .(mean_count = mean(count)),
1761128758818:by = .(gene, condition)]
1761128758831:counts_condition_wide <- dcast(gene_condition_means,
1761128758839:gene ~ condition,
1761128758845:value.var = "mean_count")
1761128758850:return(counts_condition_wide)
1761128758857:}
1761128758872:# ==========================================================
1761128758878:# ðŸ§© TASK 10 â€” ATAC peaks to genes
1761128758884:# ==========================================================
1761128758896:#' Map ATAC peaks to genes and summarize overlaps
1761128758904:#'
1761128758911:#' Uses genomic overlap to assign peaks to genes and compute overlap statistics.
1761128758916:#'
1761128758923:#' @param peaks_path Path to CSV file with columns: chr, start, end, peak_id, score
1761128758929:#' @param genes_path Path to CSV file with columns: chr, start, end, gene
1761128758935:#' @return List with overlap tables, peaks_per_gene and top 20 genes by overlap
1761128758942:#' @export
1761128758954:atac_to_gene_dt <- function(peaks_path, genes_path) {
1761128758966:peaks <- fread(peaks_path)
1761128758973:genes <- fread(genes_path)
1761128758984:setkey(peaks, chr, start, end)
1761128758991:setkey(genes, chr, start, end)
1761128759002:overlaps <- foverlaps(peaks, genes,
1761128759010:by.x = c("chr", "start", "end"),
1761128759016:by.y = c("chr", "start", "end"),
1761128759024:type = "any", nomatch = 0L)
1761128759035:overlaps[, overlap_bp := pmin(end, i.end) - pmax(start, i.start)]
1761128759048:overlaps <- overlaps[overlap_bp > 0]
1761128759059:peaks_per_gene <- overlaps[, .N, by = gene]
1761128759065:setnames(peaks_per_gene, "N", "num_peaks")
1761128759077:overlap_sum_per_gene <- overlaps[, .(total_overlap_bp = sum(overlap_bp)), by = gene]
1761128759089:top20_genes <- overlap_sum_per_gene[order(-total_overlap_bp)][1:20]
1761128759095:return(list(overlaps=overlaps, peaks_per_gene=peaks_per_gene, top20_genes=top20_genes))
1761128759101:}
1761128759114:# ==========================================================
1761128759120:# ðŸ§© TASK 11 â€” Variants to genes
1761128759126:# ==========================================================
1761128759138:#' Map genetic variants to genes and count HIGH-impact variants
1761128759144:#'
1761128759149:#' @param variants_path  Path to CSV file with columns: sample_id, chr, pos, ref, alt, impact
1761128759157:#' @param genes_path  Path to CSV file with columns: chr, start, end, gene
1761128759162:#' @return List with counts and high-impact genes
1761128759169:#' @export
1761128759177:variants_to_genes_dt <- function(variants_path, genes_path) {
1761128759189:variants <- fread(variants_path)
1761128759195:genes    <- fread(genes_path)
1761128759208:variants[, start := pos]  #creo per ogni variante un intervallo 1bp
1761128759213:variants[, end   := pos]  #foverlaps () lavora con intervalli start-end quindi gli servono
1761128759225:setkey(variants, chr, start, end)
1761128759230:setkey(genes,    chr, start, end)
1761128759242:overlaps <- foverlaps(variants, genes, type = "any", nomatch = 0L)
1761128759253:overlaps[, impact_upper := toupper(impact)]
1761128759265:high_overlaps <- overlaps[impact_upper == "HIGH"]
1761128759282:high_counts_by_gene_sample <- high_overlaps[, .(
1761128759287:high_variant_count = .N
1761128759296:), by = .(gene, sample_id)]
1761128759314:high_counts_by_gene <- high_overlaps[, .(
1761128759320:total_high_variants = .N
1761128759325:), by = gene][order(-total_high_variants)]
1761128759342:genes_with_high <- unique(high_counts_by_gene$gene)
1761128759348:return(list(overlaps=overlaps, genes_with_high = genes_with_high))
1761128759354:}
1761128759364:# ==========================================================
1761128759370:# ðŸ§© TASK 12 â€” Combine cohorts
1761128759376:# ==========================================================
1761128759387:#' Combine cohorts safely and compute per-cohort mean counts
1761128759392:#'
1761128759397:#' @param cohortA_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761128759403:#' @param cohortB_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761128759409:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128759414:#' @return List with combined cohort info and top genes
1761128759420:#' @export
1761128759432:combine_cohorts_dt <- function(cohortA_path, cohortB_path, counts_path) {
1761128759443:cohortA <- fread(cohortA_path)
1761128759449:cohortB <- fread(cohortB_path)
1761128759455:counts  <- fread(counts_path)
1761128759467:cohortA[, cohort := "A"]
1761128759473:cohortB[, cohort := "B"]
1761128759484:combined_cohorts <- rbindlist(list(cohortA, cohortB), use.names = TRUE, fill = TRUE)
1761128759495:setorder(combined_cohorts, cohort, condition, sample_id)
1761128759505:merged_per_sampleid <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761128759515:gene_variance <- merged_per_sampleid[, .(variance = var(count, na.rm = TRUE)), by = gene]
1761128759526:top100_genes <- gene_variance[order(-variance)][1:100, gene]
1761128759536:top100_data <- merged_per_sampleid[gene %in% top100_genes]
1761128759546:mean_counts <- top100_data[, .(
1761128759552:mean_count = mean(count, na.rm = TRUE)
1761128759557:), by = .(gene, cohort, condition)]
1761128759567:return(top100_data)
1761128759573:}
1761128759589:# ==========================================================
1761128759594:# ðŸ§© FINAL REVISION TASKS (1.1 â†’ 5.1)
1761128759599:# ==========================================================
1761128759609:#' Combine integration and clustering data
1761128759615:#'
1761128759620:#' Reads and merges integration and clustering tables by cell ID, ensuring consistent ID formatting.
1761128759626:#'
1761128759631:#' @export
1761128759636:combine_integration_clustering_dt <- function(integration_file, clustering_file) {
1761128759642:int <- fread(integration_file)
1761128759647:clu <- fread(clustering_file)
1761128759652:normalize <- function(x) gsub("_X_|_Y_", "_", trimws(as.character(x)))
1761128759658:int[, cell_clean := normalize(cell)]
1761128759663:clu[, cell_clean := normalize(cell)]
1761128759668:merge(int, clu, by = "cell_clean", all = FALSE)
1761128759673:}
1761128759684:#' Count cells per cluster and cell type
1761128759689:#' @export
1761128759694:count_cells_per_cluster_dt <- function(combined_dt) {
1761128759703:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type)]
1761128759708:setnames(counts, "N", "cell_count")
1761128759713:counts
1761128759718:}
1761128759730:#' Count cells per cluster, cell type, and sample type
1761128759736:#' @export
1761128759741:add_sample_type_dt <- function(combined_dt) {
1761128759746:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type, sample_type)]
1761128759751:setnames(counts, "N", "cell_count")
1761128759756:counts
1761128759762:}
1761128759774:#' Compute total cell counts per cluster and sample type
1761128759779:#' @export
1761128759785:compute_totals_dt <- function(counts_dt) {
1761128759790:counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761128759795:}
1761128759806:#' Compute normalized percentages per cluster and tissue
1761128759812:#' @export
1761128759817:compute_percentages_dt <- function(counts_dt) {
1761128759822:totals <- counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761128759827:merged <- merge(counts_dt, totals, by = c("integration_cluster", "sample_type"))
1761128759837:merged[, percent := round((cell_count / total_cells) * 100, 2)]
1761128759843:merged[order(integration_cluster)]
1761128759848:}
1761128769055:devtools::document()
1761128774844:devtools::load_all()
1761128799285:devtools::clean_dll()
1761128799299:devtools::document()
1761128799309:devtools::load_all()
1761128827861:usethis::create_package("myprojectDT")
1761128827875:usethis::use_roxygen_md()
1761128834677:+ devtools::document()
1761128834692:+ devtools::load_all()
1761128845033:devtools::document()
1761128854368:devtools::load_all()
1761128901714:library(data.table)
1761128902039:# ==========================================================
1761128902040:# ðŸ§© TASK 1 â€” Bulk RNA counts summary
1761128902041:# ==========================================================
1761128902048:#' Summarize bulk RNA counts with metadata (data.table version)
1761128902050:#'
1761128902052:#' Merges bulk RNA-seq count data with sample metadata, filters treated samples
1761128902054:#' whose gene names start with "GENE_00", and computes mean/median counts per gene,
1761128902056:#' as well as per-condition mean counts.
1761128902057:#'
1761128902058:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128902059:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128902060:#' @return List with: filtered_data, gene_mean_median, gene_condition_means
1761128902061:#' \itemize{
1761128902062:#'   \item gene_mean_median: Mean and median counts by gene (treated only)
1761128902063:#'   \item gene_condition_means: Mean counts by gene and condition
1761128902064:#' }
1761128902065:#' @export
1761128902066:bulk_counts_summary_dt <- function(counts_path, meta_path) {
1761128902067:bulk_counts <- fread(counts_path)
1761128902068:sample_meta <- fread(meta_path)
1761128902070:setkey(bulk_counts, sample_id)
1761128902071:setkey(sample_meta, sample_id)
1761128902073:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128902076:filtered_data <- join_data[condition == "treated" & grepl("^GENE_00", gene)]
1761128902078:gene_mean_median <- filtered_data[, .(
1761128902078:mean_count   = mean(count),
1761128902080:median_count = median(count)
1761128902084:), by = gene]
1761128902087:gene_condition_means <- bulk_counts[
1761128902088:sample_meta,
1761128902089:on = "sample_id"
1761128902090:][ , .(
1761128902091:mean_count = mean(count)
1761128902092:), by = .(gene, condition) ]
1761128902095:return(list(filtered_data = filtered_data, gene_mean_median = gene_mean_median, gene_condition_means = gene_condition_means))
1761128902095:}
1761128902097:# ==========================================================
1761128902097:# ðŸ§© TASK 2 â€” QC-style derived columns
1761128902098:# ==========================================================
1761128902099:#' Add QC-style derived columns (data.table version)
1761128902100:#'
1761128902100:#' Adds log2-transformed counts and a binary \code{high} flag based on gene-wise medians.
1761128902101:#'
1761128902101:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128902102:#' @return Data.table with added columns: log2_count, high.
1761128902102:#' @export
1761128902103:bulk_counts_qc_dt <- function(counts_path) {
1761128902103:counts <- fread(counts_path)
1761128902104:counts[, log2_count := log2(count)]
1761128902105:counts[, high := count > 100]
1761128902106:counts[, high := count > median(count), by = gene]
1761128902107:return(counts)
1761128902108:}
1761128902110:# ==========================================================
1761128902111:# ðŸ§© TASK 3 â€” Subset by gene and sample
1761128902111:# ==========================================================
1761128902113:#' Subset counts data using secondary index
1761128902113:#'
1761128902114:#' Joins metadata and subsets for a specific gene and sample using fast indexing.
1761128902115:#'
1761128902115:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128902116:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128902117:#' @param gene_name Gene name to subset
1761128902117:#' @param sample_chosen Sample ID to subset
1761128902118:#' @return Subset of counts for the given gene and sample.
1761128902119:#' @export
1761128902119:subset_counts_dt <- function(counts_path, meta_path, gene_call, sample_chosen) {
1761128902120:bulk_counts <- fread(counts_path)
1761128902121:sample_meta <- fread(meta_path)
1761128902122:setkey(sample_meta, sample_id)
1761128902124:join_data <- sample_meta[bulk_counts, on = "sample_id"]
1761128902125:time_no_index <- system.time({
1761128902126:subset_no_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128902127:})
1761128902128:setindex(bulk_counts, gene, sample_id)
1761128902130:time_with_index <- system.time({
1761128902131:subset_with_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761128902132:})
1761128902133:dt_benchmark <- data.table(
1761128902134:test = c("time_no_index", "time_with_index"),
1761128902134:user = c(time_no_index["user.self"], time_with_index["user.self"]),
1761128902135:system = c(time_no_index["sys.self"], time_with_index["sys.self"]),
1761128902136:elapsed = c(time_no_index["elapsed"], time_with_index["elapsed"])
1761128902137:)
1761128902140:return(dt_benchmark)
1761128902141:}
1761128902143:# ==========================================================
1761128902144:# ðŸ§© TASK 4 â€” Annotate counts and summarize
1761128902144:# ==========================================================
1761128902146:#' Annotate counts with metadata and compute summaries
1761128902147:#'
1761128902148:#' Joins counts and metadata, computes per-patient total counts,
1761128902149:#' mean counts per gene and condition, and identifies top 10 genes.
1761128902149:#'
1761128902150:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128902151:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128902152:#' @return List with patient totals, and top10 genes.
1761128902153:#' @export
1761128902154:annotate_counts_dt <- function(counts_path, meta_path) {
1761128902157:bulk_counts <- fread(counts_path)
1761128902157:sample_meta <- fread(meta_path)
1761128902160:setkey(bulk_counts, sample_id)
1761128902161:setkey(sample_meta, sample_id)
1761128902162:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761128902165:patient_tot <- join_data[, .(total_count = sum(count)), by = patient_id]
1761128902168:gene_means <- join_data[, .(mean_count = mean(count)), by = .(gene, condition)]
1761128902170:top10 <- gene_means[
1761128902171:order(condition, -mean_count)
1761128902173:][, head(.SD, 10), by = condition]
1761128902174:return(list(patient_tot = patient_tot, top10 = top10))
1761128902176:}
1761128902178:# ==========================================================
1761128902179:# ðŸ§© TASK 5 â€” Classify lab values
1761128902180:# ==========================================================
1761128902181:#' Classify lab values against reference intervals
1761128902182:#'
1761128902183:#' Joins lab results and reference ranges, classifies as "normal" or "out_of_range",
1761128902184:#' and summarizes abnormalities per patient and per lab.
1761128902185:#'
1761128902186:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128902187:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761128902188:#' @return List with merged_labs, abnormal_by_patient, abnormal_by_lab.
1761128902189:#' @export
1761128902189:classify_labs_dt <- function(labs_path, ref_path) {
1761128902191:labs <- fread(labs_path)
1761128902192:ref  <- fread(ref_path)
1761128902194:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761128902196:merged_labs <- merge(labs, ref_unique, by = "lab")
1761128902198:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761128902200:abnormal_by_patient <- merged_labs[, .(
1761128902201:total_tests = .N,
1761128902202:out_of_range = sum(status == "out_of_range")
1761128902203:), by = patient_id]
1761128902205:abnormal_by_lab <- merged_labs[, .(
1761128902206:total_tests = .N,
1761128902207:out_of_range = sum(status == "out_of_range")
1761128902208:), by = lab]
1761128902212:return(list(merged_labs = merged_labs, abnormal_by_patient = abnormal_by_patient, abnormal_by_lab = abnormal_by_lab))
1761128902213:}
1761128902215:# ==========================================================
1761128902217:# ðŸ§© TASK 6 â€” Match vitals to labs
1761128902218:# ==========================================================
1761128902220:#' Nearest-time matching of vitals and labs
1761128902221:#'
1761128902222:#' Matches nearest HR/SBP readings to each lab time and computes correlations.
1761128902224:#'
1761128902226:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761128902227:#' @param vitals_path Path to CSV file with columns: time_iso
1761128902228:#' @return List with labs_with_vitals and correlations (CRP vs HR/SBP)
1761128902229:#' @export
1761128902230:match_vitals_dt <- function(labs_path, vitals_path) {
1761128902233:labs <- fread(labs_path)
1761128902234:vitals <- fread(vitals_path)
1761128902235:labs[, time_iso := as.POSIXct(time_iso)]
1761128902236:vitals[, time_iso := as.POSIXct(time_iso)]
1761128902238:setorder(labs, patient_id, time_iso)
1761128902239:setorder(vitals, patient_id, time_iso)
1761128902243:labs[, lab_time := time_iso]
1761128902243:setkey(labs, patient_id, time_iso)
1761128902244:setkey(vitals, patient_id, time_iso)
1761128902247:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)]
1761128902247:setnames(vitals_hr, "value", "nearest_HR")
1761128902249:vitals_hr[, hr_time := time_iso]
1761128902250:setkey(vitals_hr, patient_id, time_iso)
1761128902253:labs_with_hr <- vitals_hr[labs, roll = "nearest"]
1761128902256:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761128902258:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761128902258:setnames(vitals_sbp, "value", "nearest_SBP")
1761128902260:vitals_sbp[, sbp_time := time_iso]
1761128902261:setkey(vitals_sbp, patient_id, time_iso)
1761128902263:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761128902264:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761128902267:crp_data <- labs_with_vitals[lab == "CRP"]
1761128902269:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761128902270:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761128902271:), by = patient_id]
1761128902273:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761128902274:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761128902275:), by = patient_id]
1761128902277:return(list(labs_with_hr = labs_with_hr, labs_with_vitals=labs_with_vitals, cor_crp_hr = cor_hr, cor_crp_sbp = cor_sbp))
1761128902278:}
1761128902280:# ==========================================================
1761128902281:# ðŸ§© TASK 7 â€” Top peaks by score
1761128902282:# ==========================================================
1761128902283:#' Extract peaks on chromosome and return top N by score
1761128902284:#'
1761128902285:#' Filters by genomic region and selects top peaks by score.
1761128902286:#'
1761128902287:#' @param peaks_path Path to CSV file with columns:chr, start, end, peak_id, score
1761128902289:#' @param chr_sel selected chromosome string e.g.:"chr2"
1761128902291:#' @param start_min lower bound of range e.g.:2000000
1761128902293:#' @param start_max upper bound of range e.g.:4000000
1761128902296:#' @return Data.table of top peaks
1761128902298:#' @export
1761128902299:top_peaks_dt <- function(peaks_path, chr_path, start_min , start_max) {
1761128902304:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761128902306:subset_peaks <- peaks[chr == chr_sel & start >= start_min & start <= start_max]
1761128902308:subset_peaks <- setorder(subset_peaks, -score)
1761128902312:top50_peaks <- head(subset_peaks, 50)
1761128902315:return(top50_peaks)
1761128902316:}
1761128902320:# ==========================================================
1761128902325:# ðŸ§© TASK 8 â€” Gene stats and filtering
1761128902328:# ==========================================================
1761128902330:#' Per-condition robust summary stats and gene filtering
1761128902331:#'
1761128902332:#' Computes mean, median, quartiles by gene and condition,
1761128902333:#' filters genes with treated_mean â‰¥ 2 Ã— control_mean.
1761128902334:#'
1761128902335:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128902336:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761128902341:#' @return List with stats_by_gene_condition and kept_genes
1761128902343:#' @export
1761128902346:gene_stats_filter_dt <- function(counts_path, meta_path) {
1761128902347:counts <- fread(counts_path)
1761128902348:meta   <- fread(meta_path)
1761128902350:merged <- counts[meta, on = "sample_id"]
1761128902352:stats_by_gene_condition <- merged[, .(
1761128902353:mean_count   = mean(count),
1761128902354:median_count = median(count),
1761128902358:Q1           = quantile(count, 0.25, type = 2),
1761128902360:Q3           = quantile(count, 0.75, type = 2)
1761128902361:), by = .(gene, condition)]
1761128902362:treated_means <- stats_by_gene_condition[condition == "treated", .(gene, treated_mean = mean_count)]
1761128902363:control_means <- stats_by_gene_condition[condition == "control", .(gene, control_mean = mean_count)]
1761128902365:means_wide <- merge(treated_means, control_means, by = "gene", all = FALSE)
1761128902367:kept_genes <- means_wide[treated_mean >= 2 * control_mean]
1761128902369:return(list(stats_by_gene_condition = stats_by_gene_condition, kept_genes = kept_genes))
1761128902370:}
1761128902375:# ==========================================================
1761128902377:# ðŸ§© TASK 9 â€” Wide â†’ Long â†’ Wide
1761128902377:# ==========================================================
1761128902379:#' Convert wide counts to long and back, computing mean per condition
1761128902380:#'
1761128902381:#' @param counts_wide_path Path to CSV file with columns genes and samples
1761128902382:#' @return Data.table wide by condition with mean counts
1761128902383:#' @export
1761128902384:wide_long_wide_dt <- function(counts_wide_path, meta_path) {
1761128902386:counts_wide <- fread(counts_wide_path)
1761128902399:counts_long <- melt(counts_wide, id.vars = "gene",
1761128902400:variable.name = "sample_id", value.name = "count")
1761128902403:meta <- fread(meta_path)
1761128902405:merged <- merge(counts_long, meta, by = "sample_id")
1761128902407:totals_per_sample <- merged[, .(total_count = sum(count)), by = sample_id]
1761128902408:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761128902410:gene_condition_means <- merged[, .(mean_count = mean(count)),
1761128902413:by = .(gene, condition)]
1761128902421:counts_condition_wide <- dcast(gene_condition_means,
1761128902427:gene ~ condition,
1761128902430:value.var = "mean_count")
1761128902433:return(counts_condition_wide)
1761128902435:}
1761128902437:# ==========================================================
1761128902437:# ðŸ§© TASK 10 â€” ATAC peaks to genes
1761128902438:# ==========================================================
1761128902441:#' Map ATAC peaks to genes and summarize overlaps
1761128902442:#'
1761128902453:#' Uses genomic overlap to assign peaks to genes and compute overlap statistics.
1761128902454:#'
1761128902456:#' @param peaks_path Path to CSV file with columns: chr, start, end, peak_id, score
1761128902458:#' @param genes_path Path to CSV file with columns: chr, start, end, gene
1761128902459:#' @return List with overlap tables, peaks_per_gene and top 20 genes by overlap
1761128902460:#' @export
1761128902463:atac_to_gene_dt <- function(peaks_path, genes_path) {
1761128902466:peaks <- fread(peaks_path)
1761128902467:genes <- fread(genes_path)
1761128902469:setkey(peaks, chr, start, end)
1761128902470:setkey(genes, chr, start, end)
1761128902471:overlaps <- foverlaps(peaks, genes,
1761128902472:by.x = c("chr", "start", "end"),
1761128902473:by.y = c("chr", "start", "end"),
1761128902474:type = "any", nomatch = 0L)
1761128902477:overlaps[, overlap_bp := pmin(end, i.end) - pmax(start, i.start)]
1761128902479:overlaps <- overlaps[overlap_bp > 0]
1761128902480:peaks_per_gene <- overlaps[, .N, by = gene]
1761128902482:setnames(peaks_per_gene, "N", "num_peaks")
1761128902484:overlap_sum_per_gene <- overlaps[, .(total_overlap_bp = sum(overlap_bp)), by = gene]
1761128902486:top20_genes <- overlap_sum_per_gene[order(-total_overlap_bp)][1:20]
1761128902487:return(list(overlaps=overlaps, peaks_per_gene=peaks_per_gene, top20_genes=top20_genes))
1761128902488:}
1761128902491:# ==========================================================
1761128902491:# ðŸ§© TASK 11 â€” Variants to genes
1761128902492:# ==========================================================
1761128902494:#' Map genetic variants to genes and count HIGH-impact variants
1761128902495:#'
1761128902496:#' @param variants_path  Path to CSV file with columns: sample_id, chr, pos, ref, alt, impact
1761128902497:#' @param genes_path  Path to CSV file with columns: chr, start, end, gene
1761128902498:#' @return List with counts and high-impact genes
1761128902502:#' @export
1761128902505:variants_to_genes_dt <- function(variants_path, genes_path) {
1761128902512:variants <- fread(variants_path)
1761128902513:genes    <- fread(genes_path)
1761128902515:variants[, start := pos]  #creo per ogni variante un intervallo 1bp
1761128902515:variants[, end   := pos]  #foverlaps () lavora con intervalli start-end quindi gli servono
1761128902517:setkey(variants, chr, start, end)
1761128902517:setkey(genes,    chr, start, end)
1761128902519:overlaps <- foverlaps(variants, genes, type = "any", nomatch = 0L)
1761128902520:overlaps[, impact_upper := toupper(impact)]
1761128902526:high_overlaps <- overlaps[impact_upper == "HIGH"]
1761128902529:high_counts_by_gene_sample <- high_overlaps[, .(
1761128902530:high_variant_count = .N
1761128902531:), by = .(gene, sample_id)]
1761128902533:high_counts_by_gene <- high_overlaps[, .(
1761128902534:total_high_variants = .N
1761128902535:), by = gene][order(-total_high_variants)]
1761128902539:genes_with_high <- unique(high_counts_by_gene$gene)
1761128902540:return(list(overlaps=overlaps, genes_with_high = genes_with_high))
1761128902541:}
1761128902543:# ==========================================================
1761128902544:# ðŸ§© TASK 12 â€” Combine cohorts
1761128902545:# ==========================================================
1761128902546:#' Combine cohorts safely and compute per-cohort mean counts
1761128902547:#'
1761128902548:#' @param cohortA_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761128902549:#' @param cohortB_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761128902550:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761128902553:#' @return List with combined cohort info and top genes
1761128902553:#' @export
1761128902557:combine_cohorts_dt <- function(cohortA_path, cohortB_path, counts_path) {
1761128902559:cohortA <- fread(cohortA_path)
1761128902560:cohortB <- fread(cohortB_path)
1761128902561:counts  <- fread(counts_path)
1761128902563:cohortA[, cohort := "A"]
1761128902564:cohortB[, cohort := "B"]
1761128902566:combined_cohorts <- rbindlist(list(cohortA, cohortB), use.names = TRUE, fill = TRUE)
1761128902568:setorder(combined_cohorts, cohort, condition, sample_id)
1761128902570:merged_per_sampleid <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761128902572:gene_variance <- merged_per_sampleid[, .(variance = var(count, na.rm = TRUE)), by = gene]
1761128902576:top100_genes <- gene_variance[order(-variance)][1:100, gene]
1761128902579:top100_data <- merged_per_sampleid[gene %in% top100_genes]
1761128902580:mean_counts <- top100_data[, .(
1761128902581:mean_count = mean(count, na.rm = TRUE)
1761128902582:), by = .(gene, cohort, condition)]
1761128902584:return(top100_data)
1761128902585:}
1761128902592:# ==========================================================
1761128902594:# ðŸ§© FINAL REVISION TASKS (1.1 â†’ 5.1)
1761128902595:# ==========================================================
1761128902598:#' Combine integration and clustering data
1761128902599:#'
1761128902601:#' Reads and merges integration and clustering tables by cell ID, ensuring consistent ID formatting.
1761128902602:#'
1761128902603:#' @export
1761128902604:combine_integration_clustering_dt <- function(integration_file, clustering_file) {
1761128902606:int <- fread(integration_file)
1761128902608:clu <- fread(clustering_file)
1761128902609:normalize <- function(x) gsub("_X_|_Y_", "_", trimws(as.character(x)))
1761128902611:int[, cell_clean := normalize(cell)]
1761128902613:clu[, cell_clean := normalize(cell)]
1761128902614:merge(int, clu, by = "cell_clean", all = FALSE)
1761128902615:}
1761128902618:#' Count cells per cluster and cell type
1761128902620:#' @export
1761128902624:count_cells_per_cluster_dt <- function(combined_dt) {
1761128902626:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type)]
1761128902627:setnames(counts, "N", "cell_count")
1761128902628:counts
1761128902629:}
1761128902632:#' Count cells per cluster, cell type, and sample type
1761128902635:#' @export
1761128902638:add_sample_type_dt <- function(combined_dt) {
1761128902639:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type, sample_type)]
1761128902643:setnames(counts, "N", "cell_count")
1761128902646:counts
1761128902648:}
1761128902652:#' Compute total cell counts per cluster and sample type
1761128902654:#' @export
1761128902659:compute_totals_dt <- function(counts_dt) {
1761128902662:counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761128902663:}
1761128902666:#' Compute normalized percentages per cluster and tissue
1761128902667:#' @export
1761128902669:compute_percentages_dt <- function(counts_dt) {
1761128902671:totals <- counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761128902674:merged <- merge(counts_dt, totals, by = c("integration_cluster", "sample_type"))
1761128902677:merged[, percent := round((cell_count / total_cells) * 100, 2)]
1761128902678:merged[order(integration_cluster)]
1761128902679:}
1761128918281:devtools::document()
1761128928694:devtools::load_all()
1761140738286:# ==========================================================
1761140738289:# df_functions.R
1761140738292:# Generalized and reusable base R (data.frame) functions
1761140738293:# for bulk RNA-seq processing and summarization
1761140738295:# ==========================================================
1761140738297:# ----------------------------------------------------------
1761140738298:# TASK 1 â€“ Merge, filter, summarize, and compute per-condition means
1761140738299:# ----------------------------------------------------------
1761140738299:bulk_counts_summary_df <- function(counts_path, meta_path) {
1761140738300:# 1. Import
1761140738301:counts <- read.csv(counts_path)
1761140738303:meta   <- read.csv(meta_path)
1761140738304:# 2. Join counts + metadata by sample_id
1761140738306:merged_data <- merge(counts, meta, by = "sample_id")
1761140738312:# 3. Filter for treated samples and GENE_00* genes
1761140738315:treated_data <- subset(merged_data,
1761140738318:condition == "treated" & grepl("^GENE_00", gene))
1761140738323:# 4. Compute mean and median per gene
1761140738325:gene_summary <- aggregate(
1761140738327:count ~ gene,
1761140738330:data = treated_data,
1761140738331:FUN  = function(x) c(mean = mean(x), median = median(x))
1761140738333:)
1761140738335:# 5. Simplify format
1761140738336:gene_summary_df <- data.frame(
1761140738338:gene = gene_summary$gene,
1761140738339:mean_count   = gene_summary$count[, "mean"],
1761140738340:median_count = gene_summary$count[, "median"]
1761140738342:)
1761140738344:# 6 Calcolo della media dei conteggi per ciascun gene e condizione
1761140738345:# aggregate() calcola una funzione (mean) per gruppi
1761140738346:gene_condition_means_f <- aggregate(
1761140738350:count ~ gene + condition,   # formula: raggruppa per gene e condition
1761140738351:data = merged_data,         # tabella di partenza
1761140738352:FUN = mean,                 # funzione da applicare
1761140738352:na.rm = TRUE                # ignora eventuali valori mancanti
1761140738353:)
1761140738354:# 7 Ordina i risultati per gene e condition (per leggibilitÃ )
1761140738356:gene_condition_means_f <- gene_condition_means_f[order(gene_condition_means_f$gene,
1761140738358:gene_condition_means_f$condition), ]
1761140738360:}
1761140738362:# ----------------------------------------------------------
1761140738363:# TASK 2 â€“ Add log2(count + 1) and binary flags
1761140738364:# ----------------------------------------------------------
1761140738365:bulk_counts_qc_df <- function(counts_path) {
1761140738366:# 1. Import
1761140738367:counts <- read.csv(counts_path)
1761140738370:# 2. Add log2(count + 1) column
1761140738370:counts$log2_count <- log2(counts$count + 1)
1761140738372:# 3. Add binary flag 'high' (count > 100)
1761140738373:counts$high <- counts$count > 100
1761140738374:# 4. Overwrite 'high' using gene-wise median threshold
1761140738375:#    Qui usiamo tapply() per calcolare la mediana per gene,
1761140738375:#    poi combiniamo i risultati in un vettore logico della stessa lunghezza
1761140738376:medians_by_gene <- tapply(counts$count, counts$gene, median)
1761140738377:counts$high <- counts$count > medians_by_gene[counts$gene]
1761140738378:}
1761140738379:#-----------------------------------------------------------
1761140738380:#Task 3 non ha la funzione perchÃ¨ ha senso solo in data.table
1761140738381:#-----------------------------------------------------------
1761140738383:# ----------------------------------------------------------
1761140738384:# TASK 4 â€“ Filter genes by thresholded normalized expression
1761140738385:# ----------------------------------------------------------
1761140738386:annotate_counts_df <- function(counts_path, meta_path) {
1761140738387:counts <- read.csv(counts_path)
1761140738388:meta   <- read.csv(meta_path, stringsAsFactors = FALSE)
1761140738389:# 2. Join
1761140738390:merged_data <- merge(counts, meta, by = "sample_id")
1761140738392:# 3. Total counts per patient
1761140738394:patient_totals <- aggregate(count ~ patient_id, data = merged_data, FUN = sum)
1761140738395:names(patient_totals)[2] <- "total_count"
1761140738398:# 4. Mean count per gene and condition
1761140738400:gene_means <- aggregate(count ~ gene + condition, data = merged_data, FUN = mean)
1761140738402:names(gene_means)[3] <- "mean_count"
1761140738405:# 5. Top 10 genes by condition
1761140738406:conditions <- unique(gene_means$condition)
1761140738410:top10_by_condition <- data.frame()
1761140738412:for (cond in conditions) {
1761140738414:subset_cond <- subset(gene_means, condition == cond)
1761140738415:subset_cond <- subset_cond[order(-subset_cond$mean_count), ]
1761140738416:top10 <- head(subset_cond, 10)
1761140738417:top10_by_condition <- rbind(top10_by_condition, top10)}
1761140738420:}
1761140738423:# ----------------------------------------------------------
1761140738424:# TASK 5 â€“ Summary table by condition and gene class
1761140738425:# ----------------------------------------------------------
1761140738426:classify_labs_df <- function(labs_path, ref_path) {
1761140738428:# 1. Import
1761140738429:labs <- read.csv(labs_path)
1761140738430:ref  <- read.csv(ref_path)
1761140738432:# 2. Keep unique reference intervals
1761140738432:ref_unique <- unique(ref[, c("lab", "lower", "upper")])
1761140738435:# 3. Join
1761140738437:merged_labs <- merge(labs, ref_unique, by = "lab")
1761140738441:# 4. Classify as normal/out_of_range
1761140738443:merged_labs$status <- ifelse(merged_labs$value >= merged_labs$lower &
1761140738445:merged_labs$value <= merged_labs$upper,
1761140738448:"normal", "out_of_range")
1761140738450:# 5. Summaries
1761140738454:abnormal_by_patient <- aggregate(status ~ patient_id, data = merged_labs,
1761140738459:FUN = function(x) {
1761140738462:total <- length(x)
1761140738463:out   <- sum(x == "out_of_range")
1761140738464:c(total_tests = total, out_of_range = out)
1761140738465:})
1761140738467:# split matrix-like column into two numeric columns
1761140738469:abnormal_by_patient$total_tests  <- abnormal_by_patient$status[, "total_tests"]
1761140738470:abnormal_by_patient$out_of_range <- abnormal_by_patient$status[, "out_of_range"]
1761140738470:abnormal_by_patient$status <- NULL
1761140738472:abnormal_by_lab <- aggregate(status ~ lab, data = merged_labs,
1761140738473:FUN = function(x) {
1761140738474:total <- length(x)
1761140738475:out   <- sum(x == "out_of_range")
1761140738476:c(total_tests = total, out_of_range = out)
1761140738476:})
1761140738478:abnormal_by_lab$total_tests  <- abnormal_by_lab$status[, "total_tests"]
1761140738479:abnormal_by_lab$out_of_range <- abnormal_by_lab$status[, "out_of_range"]
1761140738480:abnormal_by_lab$status <- NULL
1761140738481:}
1761140738484:# ----------------------------------------------------------
1761140738485:# TASK 6 â€“ Compute fold change between treated and control
1761140738485:# ----------------------------------------------------------
1761140738486:match_vitals_df <- function(labs_path, vitals_path) {
1761140738487:# 1. Import
1761140738488:labs   <- read.csv(labs_path)
1761140738489:vitals <- read.csv(vitals_path)
1761140738490:# 2. Convert to POSIXct
1761140738491:labs$time_iso   <- as.POSIXct(labs$time_iso)
1761140738491:vitals$time_iso <- as.POSIXct(vitals$time_iso)
1761140738493:# 3. Join nearest HR/SBP manually (loop-based)
1761140738493:nearest_match <- function(lab_df, vitals_df, vital_type) {
1761140738494:vitals_sub <- vitals_df[vitals_df$vital == vital_type, ]
1761140738495:results <- list()
1761140738496:for (i in seq_len(nrow(lab_df))) {
1761140738497:pid <- lab_df$patient_id[i]
1761140738498:time <- lab_df$time_iso[i]
1761140738499:v_sub <- vitals_sub[vitals_sub$patient_id == pid, ]
1761140738500:if (nrow(v_sub) > 0) {
1761140738501:idx <- which.min(abs(difftime(v_sub$time_iso, time, units = "mins")))
1761140738502:results[[i]] <- v_sub[idx, c("value", "time_iso")]
1761140738503:} else {
1761140738504:results[[i]] <- data.frame(value = NA, time_iso = NA)
1761140738505:}
1761140738506:}
1761140738506:out <- do.call(rbind, results)
1761140738507:names(out) <- c(paste0("nearest_", vital_type), paste0(vital_type, "_time"))
1761140738509:return(out)
1761140738510:}
1761140738512:# 4. Attach nearest HR and SBP
1761140738513:hr_data  <- nearest_match(labs, vitals, "HR")
1761140738514:sbp_data <- nearest_match(labs, vitals, "SBP")
1761140738517:labs_with_vitals <- cbind(labs, hr_data, sbp_data)
1761140738519:labs_with_vitals$hr_lag_minutes  <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$HR_time, units = "mins"))
1761140738520:labs_with_vitals$sbp_lag_minutes <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$SBP_time, units = "mins"))
1761140738522:# 5. Correlation per patient (CRP only) â€” robust version in base R
1761140738523:crp_data <- subset(labs_with_vitals, lab == "CRP")
1761140738525:# Split by patient_id
1761140738527:patients_list <- split(crp_data, crp_data$patient_id)
1761140738532:# Function to compute correlation safely
1761140738534:safe_cor <- function(df, col_x = "value", col_y = "nearest_HR") {
1761140738535:if (nrow(df) < 2) return(NA_real_)           # meno di 2 osservazioni -> NA
1761140738537:x <- df[[col_x]]
1761140738538:y <- df[[col_y]]
1761140738540:# keep only pairs non-NA
1761140738543:ok <- !is.na(x) & !is.na(y)
1761140738545:if (sum(ok) < 2) return(NA_real_)            # meno di 2 coppie valide -> NA
1761140738546:return(cor(x[ok], y[ok], use = "complete.obs"))
1761140738548:}
1761140738552:# Calcola correlazione CRP vs HR per ogni paziente
1761140738554:cor_crp_hr <- data.frame(
1761140738555:patient_id = names(patients_list),
1761140738557:correlation_CRP_HR = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_HR"),
1761140738559:row.names = NULL,
1761140738560:stringsAsFactors = FALSE
1761140738562:)
1761140738566:# Calcola correlazione CRP vs SBP per ogni paziente
1761140738568:cor_crp_sbp <- data.frame(
1761140738569:patient_id = names(patients_list),
1761140738573:correlation_CRP_SBP = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_SBP"),
1761140738574:row.names = NULL,
1761140738578:stringsAsFactors = FALSE
1761140738580:)
1761140738583:}
1761140738585:# ----------------------------------------------------------
1761140738586:# TASK 7 â€“ Compute coefficient of variation (CV)
1761140738587:# ----------------------------------------------------------
1761140738588:top_peaks_df <- function(peaks_path) {
1761140738590:peaks <- read.csv(peaks_path, stringsAsFactors = FALSE)
1761140738591:subset_peaks <- subset(peaks, chr == "chr2" & start >= 2000000 & start <= 4000000)
1761140738592:subset_peaks <- subset_peaks[order(-subset_peaks$score), ]
1761140738593:top50_peaks <- head(subset_peaks, 50)
1761140738595:cat("\n--- Top 50 picchi su chr2 (2â€“4 Mb) ---\n")
1761140738596:print(top50_peaks)
1761140738597:}
1761140738600:# ----------------------------------------------------------
1761140738601:# TASK 8 â€“ Identify most variable genes
1761140738602:# ----------------------------------------------------------
1761140738603:gene_stats_filter_df <- function(counts_path, meta_path) {
1761140738604:counts <- read.csv(counts_path, stringsAsFactors = FALSE)
1761140738605:meta   <- read.csv(meta_path, stringsAsFactors = FALSE)
1761140738607:merged <- merge(counts, meta, by = "sample_id")
1761140738610:stats_by_gene_condition <- aggregate(count ~ gene + condition, data = merged,
1761140738611:FUN = function(x) c(mean = mean(x), median = median(x),
1761140738612:Q1 = quantile(x, 0.25, type = 2),
1761140738613:Q3 = quantile(x, 0.75, type = 2)))
1761140738616:stats_df <- data.frame(
1761140738618:gene = stats_by_gene_condition$gene,
1761140738621:condition = stats_by_gene_condition$condition,
1761140738624:mean_count = stats_by_gene_condition$count[, "mean"],
1761140738625:median_count = stats_by_gene_condition$count[, "median"],
1761140738627:Q1 = stats_by_gene_condition$count[, "Q1.25%"],
1761140738628:Q3 = stats_by_gene_condition$count[, "Q3.75%"]
1761140738630:)
1761140738631:treated <- subset(stats_df, condition == "treated")[, c("gene", "mean_count")]
1761140738632:control <- subset(stats_df, condition == "control")[, c("gene", "mean_count")]
1761140738633:names(treated)[2] <- "treated_mean"
1761140738634:names(control)[2] <- "control_mean"
1761140738636:means_wide <- merge(treated, control, by = "gene")
1761140738637:kept_genes <- subset(means_wide, treated_mean >= 2 * control_mean)
1761140738639:}
1761140738642:# ----------------------------------------------------------
1761140738647:# TASK 9 â€“ Compute correlation matrix across samples
1761140738649:# ----------------------------------------------------------
1761140738650:wide_long_wide_df <- function(counts_path, meta_path) {
1761140738651:counts_wide <- read.csv(counts_path, stringsAsFactors = FALSE)
1761140738652:counts_long <- reshape(counts_wide, varying = names(counts_wide)[-1],
1761140738653:v.names = "count", timevar = "sample_id",
1761140738654:times = names(counts_wide)[-1], idvar = "gene",
1761140738655:direction = "long")
1761140738657:meta <- read.csv(meta_path, stringsAsFactors = FALSE)
1761140738657:merged <- merge(counts_long, meta, by = "sample_id")
1761140738660:totals_per_sample <- aggregate(count ~ sample_id, data = merged, sum)
1761140738660:names(totals_per_sample)[2] <- "total_count"
1761140738663:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761140738665:gene_condition_means <- aggregate(count ~ gene + condition, data = merged, mean)
1761140738665:counts_condition_wide <- reshape(gene_condition_means,
1761140738667:timevar = "condition", idvar = "gene",
1761140738667:direction = "wide")
1761140738669:cat("\n--- Tabella finale: media dei conteggi per gene e condizione ---\n")
1761140738670:print(head(counts_condition_wide, 10))
1761140738672:}
1761140738673:# ----------------------------------------------------------
1761140738674:# TASK 10 â€“ PCA on normalized data
1761140738675:# ----------------------------------------------------------
1761140738675:atac_to_gene_df <- function(peaks_path, genes_path) {
1761140738676:peaks <- read.csv(peaks_path, stringsAsFactors = FALSE)
1761140738678:genes <- read.csv(genes_path, stringsAsFactors = FALSE)
1761140738679:# overlap calcolato â€œa manoâ€
1761140738680:overlaps_list <- lapply(1:nrow(peaks), function(i) {
1761140738681:p <- peaks[i, ]
1761140738682:gsub <- subset(genes, chr == p$chr & start <= p$end & end >= p$start)
1761140738683:if (nrow(gsub) == 0) return(NULL)
1761140738684:gsub$overlap_bp <- pmin(p$end, gsub$end) - pmax(p$start, gsub$start)
1761140738684:gsub <- gsub[gsub$overlap_bp > 0, ]
1761140738685:gsub$peak_id <- i
1761140738686:gsub
1761140738687:})
1761140738688:overlaps <- do.call(rbind, overlaps_list)
1761140738691:peaks_per_gene <- aggregate(overlap_bp ~ gene, data = overlaps, FUN = length)
1761140738692:names(peaks_per_gene)[2] <- "num_peaks"
1761140738694:overlap_sum_per_gene <- aggregate(overlap_bp ~ gene, data = overlaps, sum)
1761140738695:names(overlap_sum_per_gene)[2] <- "total_overlap_bp"
1761140738696:top20_genes <- head(overlap_sum_per_gene[order(-overlap_sum_per_gene$total_overlap_bp), ], 20)
1761140738697:}
1761140738700:# ----------------------------------------------------------
1761140738700:# TASK 11 â€“ Plot gene expression distribution
1761140738701:# ----------------------------------------------------------
1761140738702:variants_to_genes_df <- function(variants_path, genes_path) {
1761140738704:variants <- read.csv(variants_path)
1761140738705:genes    <- read.csv(genes_path)
1761140738706:# 2ï¸âƒ£ Creo intervalli 1-bp per le varianti -----------------------------------
1761140738707:# Ogni variante Ã¨ un punto, quindi creo due colonne identiche (start, end)
1761140738708:variants$start <- variants$pos
1761140738709:variants$end   <- variants$pos
1761140738711:# 3 Trovo le varianti che si sovrappongono a ciascun gene ------------------
1761140738711:# (equivalente a foverlaps)
1761140738712:# Facciamo un ciclo semplice: per ogni variante controlliamo se rientra nellâ€™intervallo del gene
1761140738713:# Questo Ã¨ molto meno efficiente, ma chiaro e comprensibile
1761140738714:overlaps_list <- list()
1761140738715:for (i in seq_len(nrow(variants))) {
1761140738716:var_chr   <- variants$chr[i]
1761140738717:var_start <- variants$start[i]
1761140738718:var_end   <- variants$end[i]
1761140738719:# Trova i geni sullo stesso cromosoma che si sovrappongono a quella variante?????
1761140738721:overlapping_genes <- subset(genes,
1761140738722:chr == var_chr &
1761140738722:start <= var_end &
1761140738723:end >= var_start)
1761140738725:# Se ci sono geni che si sovrappongono, li aggiungo alla lista
1761140738726:if (nrow(overlapping_genes) > 0) {
1761140738727:tmp <- data.frame(
1761140738728:sample_id = variants$sample_id[i],
1761140738729:gene = overlapping_genes$gene,
1761140738730:chr = var_chr,
1761140738733:pos = var_start,
1761140738734:impact = variants$impact[i],
1761140738736:stringsAsFactors = FALSE
1761140738737:)
1761140738738:overlaps_list[[length(overlaps_list) + 1]] <- tmp
1761140738741:}
1761140738742:}
1761140738744:# Combino tutti i risultati in un unico data.frame
1761140738745:if (length(overlaps_list) > 0) {
1761140738747:overlaps <- do.call(rbind, overlaps_list)
1761140738748:} else {
1761140738750:overlaps <- data.frame()
1761140738750:}
1761140738752:# 4ï¸âƒ£ Normalizzo la colonna impact a maiuscolo --------------------------------
1761140738753:if (nrow(overlaps) > 0) {
1761140738754:overlaps$impact_upper <- toupper(overlaps$impact)
1761140738755:}
1761140738756:# 5ï¸âƒ£ Filtro solo le varianti di alto impatto ---------------------------------
1761140738757:high_overlaps <- subset(overlaps, impact_upper == "HIGH")
1761140738759:# 6ï¸âƒ£ Conteggio delle varianti HIGH per gene e per sample ---------------------
1761140738760:if (nrow(high_overlaps) > 0) {
1761140738761:high_counts_by_gene_sample <- aggregate(
1761140738762:x = list(high_variant_count = high_overlaps$impact_upper),
1761140738764:by = list(gene = high_overlaps$gene, sample_id = high_overlaps$sample_id),
1761140738766:FUN = length
1761140738768:)
1761140738770:} else {
1761140738773:high_counts_by_gene_sample <- data.frame()
1761140738775:}
1761140738777:# 7ï¸âƒ£ Conteggio totale delle varianti HIGH per gene --------------------------
1761140738778:if (nrow(high_overlaps) > 0) {
1761140738779:high_counts_by_gene <- aggregate(
1761140738780:x = list(total_high_variants = high_overlaps$impact_upper),
1761140738781:by = list(gene = high_overlaps$gene),
1761140738782:FUN = length
1761140738782:)
1761140738785:# Ordina in modo decrescente
1761140738786:high_counts_by_gene <- high_counts_by_gene[order(-high_counts_by_gene$total_high_variants), ]
1761140738788:# Geni con almeno una variante HIGH
1761140738788:genes_with_high <- unique(high_counts_by_gene$gene)
1761140738789:} else {
1761140738790:high_counts_by_gene <- data.frame()
1761140738791:genes_with_high <- character(0)
1761140738792:}
1761140738794:# 8ï¸âƒ£ Salvo i risultati su file CSV ------------------------------------------
1761140738795:write.csv(high_counts_by_gene_sample, "project_oct25/high_variants_by_gene_sample.csv", row.names = FALSE)
1761140738796:write.csv(high_counts_by_gene, "project_oct25/high_variants_by_gene_total.csv", row.names = FALSE)
1761140738797:write.csv(data.frame(gene = genes_with_high), "project_oct25/genes_with_high_variants.csv", row.names = FALSE)
1761140738799:cat("\nAnalisi completata. File salvati in project_oct25/.\n")
1761140738800:}
1761140738803:# ----------------------------------------------------------
1761140738804:# TASK 12 â€“ Compute summary statistics
1761140738805:# ----------------------------------------------------------
1761140738805:combine_cohorts_df <- function(cohortA_path, cohortB_path, counts_path) {
1761140738806:cohortA <- read.csv(cohortA_path, stringsAsFactors = FALSE)
1761140738807:cohortB <- read.csv(cohortB_path, stringsAsFactors = FALSE)
1761140738808:counts  <- read.csv(counts_path, stringsAsFactors = FALSE)
1761140738809:cohortA$cohort <- "A"
1761140738810:cohortB$cohort <- "B"
1761140738814:combined_cohorts <- rbind(cohortA, cohortB)
1761140738815:combined_cohorts <- combined_cohorts[order(combined_cohorts$cohort,
1761140738818:combined_cohorts$condition,
1761140738820:combined_cohorts$sample_id), ]
1761140738821:merged <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761140738823:gene_variance <- aggregate(count ~ gene, data = merged, FUN = var, na.rm = TRUE)
1761140738824:names(gene_variance)[2] <- "variance"
1761140738825:top100_genes <- head(gene_variance[order(-gene_variance$variance), "gene"], 100)
1761140738829:top100_data <- subset(merged, gene %in% top100_genes)
1761140738830:mean_counts <- aggregate(count ~ gene + cohort + condition,
1761140738831:data = top100_data, FUN = mean, na.rm = TRUE)
1761140738832:names(mean_counts)[4] <- "mean_count"
1761140738833:}
1761140758991:devtools::document()
1761140768381:devtools::load_all()
1761140862693:library(data.table)
1761140863178:library(microbenchmark)
1761140863671:library(ggplot2)
1761140864718:# carico le funzioni
1761140864726:source("R/df_functions.R")
1761140866260:source("R/dt_functions.R")
1761140867203:# Task 1
1761140867209:bench1 <- microbenchmark(
1761140867210:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761140867213:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761140867215:times = 10
1761140867217:)
1761140874044:autoplot(bench1)
1761140880892:# Task 2
1761140880897:bench2 <- microbenchmark(
1761140880898:df_version = bulk_counts_qc_df("project_oct25/bulk_counts_long.csv"),
1761140880899:dt_version = bulk_counts_qc_dt("project_oct25/bulk_counts_long.csv"),
1761140880900:times = 10
1761140880900:)
1761140884499:autoplot(bench2)
1761140887586:# Task 4
1761140887590:bench4 <- microbenchmark(
1761140887591:df_version = annotate_counts_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761140887593:dt_version = annotate_counts_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761140887594:times = 10
1761140887596:)
1761140896822:autoplot(bench4)
1761140898392:# Task 5
1761140898397:bench5 <- microbenchmark(
1761140898399:df_version = classify_labs_df("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761140898401:dt_version = classify_labs_dt("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761140898403:times = 10
1761140898405:)
1761140902128:autoplot(bench5)
1761140903843:# Task 6
1761140903849:bench6 <- microbenchmark(
1761140903854:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761140903857:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761140903860:times = 10
1761140903864:)
1761141111787:autoplot(bench6)
1761141113319:# Task 7
1761141113323:bench7 <- microbenchmark(
1761141113324:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv"),
1761141113326:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv"),
1761141113327:times = 10
1761141113330:)
1761141132610:autoplot(bench7)
1761141134261:# Task 8
1761141134264:bench8 <- microbenchmark(
1761141134268:df_version = gene_stats_filter_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761141134269:dt_version = gene_stats_filter_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761141134271:times = 10
1761141134275:)
1761141145568:autoplot(bench8)
1761141145843:# Task 9
1761141145843:bench9 <- microbenchmark(
1761141145844:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv"),
1761141145846:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv"),
1761141145850:times = 10
1761141145851:)
1761141217325:autoplot(bench9)
1761141220891:# Task 10
1761141220895:bench10 <- microbenchmark(
1761141220896:df_version = atac_to_gene_df("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761141220898:dt_version = atac_to_gene_dt("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761141220899:times = 10
1761141220900:)
1761141241941:autoplot(bench10)
1761141242242:# Task 11
1761141242243:bench11 <- microbenchmark(
1761141242244:df_version = variants_to_genes_df("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761141242245:dt_version = variants_to_genes_dt("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761141242246:times = 10
1761141242247:)
1761141249572:autoplot(bench11)
1761141258996:# Task 12
1761141259009:bench12 <- microbenchmark(
1761141259011:df_version = combine_cohorts_df("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761141259012:dt_version = combine_cohorts_dt("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761141259017:times = 10
1761141259022:)
1761141265125:autoplot(bench12)
1761141281114:View(bench1)
1761141876570:# Task 6
1761141876574:bench6 <- microbenchmark(
1761141876575:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761141876576:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761141876577:times = 10
1761141876579:)
1761141914629:#TASK 6: Nearest-time matching of vitals to lab draws
1761141914633:# =====================================================
1761141914634:library(data.table)
1761141915315:# 1. Carico i dati
1761141915323:labs <- fread("project_oct25/clinical_labs.csv")
1761141915946:vitals <- fread("project_oct25/vitals_time_series.csv")
1761141916757:# 2. Preparo le tabelle e converte le date in un formato tempo che R puÃ² confrontare
1761141916762:labs[, time_iso := as.POSIXct(time_iso)]
1761141917420:vitals[, time_iso := as.POSIXct(time_iso)]
1761141917921:#ordina i dati per paziente e per tempo, serve per i join temporali
1761141917927:setorder(labs, patient_id, time_iso)
1761141918404:setorder(vitals, patient_id, time_iso)
1761141921744:# Salvo il tempo del laboratorio, creando una nuova colonna lab_time con l'orario del prelievo
1761141921747:labs[, lab_time := time_iso]
1761141921937:#imposto le chiavi, importante per il join
1761141921950:setkey(labs, patient_id, time_iso)
1761141922086:setkey(vitals, patient_id, time_iso)
1761141922254:# 3. Trovo l'HR piÃ¹ vicino
1761141922257:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)] #prendo solo le righe dei HR
1761141922463:setnames(vitals_hr, "value", "nearest_HR") #rinomino la colonna value in nearest HR
1761141922585:# SALVO IL TEMPO DELL'HR PRIMA DEL JOIN!
1761141922588:vitals_hr[, hr_time := time_iso] #salvo l'ora della misura HR
1761141922749:setkey(vitals_hr, patient_id, time_iso)
1761141922910:labs_with_hr <- vitals_hr[labs, roll = "nearest"] #rolling join
1761141923083:#per ogni esame di lab, trova il battito HR piÃ¹ vicino nel tempo x lo stesso paziente
1761141923090:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761141923249:# 4. Trovo l'SBP piÃ¹ vicino, esattamente lo stesso per pressione
1761141923254:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761141923428:setnames(vitals_sbp, "value", "nearest_SBP")
1761141923594:# SALVO IL TEMPO DELL'SBP PRIMA DEL JOIN!
1761141923597:vitals_sbp[, sbp_time := time_iso]
1761141923774:setkey(vitals_sbp, patient_id, time_iso)
1761141923952:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761141924113:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761141924270:# 6. Analisi CRP: filtra solo le righe dove il lab Ã¨ CRP
1761141924274:crp_data <- labs_with_vitals[lab == "CRP"]
1761141924445:#per ogni paziente (by sample id) calcola la correlazione tra CRP e battito e CRP e pressione
1761141924448:#complete.obs: ignora le righe con dati mancanti
1761141924449:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761141924451:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761141924452:), by = patient_id]
1761141924644:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761141924649:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761141924652:), by = patient_id]
1761141931796:# 1. Import
1761141931799:labs   <- read.csv("project_oct25/clinical_labs.csv")
1761141931953:vitals <- read.csv("project_oct25/vitals_time_series.csv")
1761141932092:# 2. Convert to POSIXct
1761141932096:labs$time_iso   <- as.POSIXct(labs$time_iso)
1761141932275:vitals$time_iso <- as.POSIXct(vitals$time_iso)
1761141932428:# 3. Join nearest HR/SBP manually (loop-based)
1761141932430:nearest_match <- function(lab_df, vitals_df, vital_type) {
1761141932431:vitals_sub <- vitals_df[vitals_df$vital == vital_type, ]
1761141932433:results <- list()
1761141932434:for (i in seq_len(nrow(lab_df))) {
1761141932436:pid <- lab_df$patient_id[i]
1761141932437:time <- lab_df$time_iso[i]
1761141932438:v_sub <- vitals_sub[vitals_sub$patient_id == pid, ]
1761141932439:if (nrow(v_sub) > 0) {
1761141932441:idx <- which.min(abs(difftime(v_sub$time_iso, time, units = "mins")))
1761141932442:results[[i]] <- v_sub[idx, c("value", "time_iso")]
1761141932443:} else {
1761141932444:results[[i]] <- data.frame(value = NA, time_iso = NA)
1761141932444:}
1761141932445:}
1761141932446:out <- do.call(rbind, results)
1761141932449:names(out) <- c(paste0("nearest_", vital_type), paste0(vital_type, "_time"))
1761141932450:return(out)
1761141932451:}
1761141932623:# 4. Attach nearest HR and SBP
1761141932626:hr_data  <- nearest_match(labs, vitals, "HR")
1761141933099:sbp_data <- nearest_match(labs, vitals, "SBP")
1761141933374:labs_with_vitals <- cbind(labs, hr_data, sbp_data)
1761141933761:labs_with_vitals$hr_lag_minutes  <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$HR_time, units = "mins"))
1761141933943:labs_with_vitals$sbp_lag_minutes <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$SBP_time, units = "mins"))
1761141934098:# 5. Correlation per patient (CRP only) â€” robust version in base R
1761141934102:crp_data <- subset(labs_with_vitals, lab == "CRP")
1761141934270:# Split by patient_id
1761141934273:patients_list <- split(crp_data, crp_data$patient_id)
1761141934541:# Function to compute correlation safely
1761141934542:safe_cor <- function(df, col_x = "value", col_y = "nearest_HR") {
1761141934543:if (nrow(df) < 2) return(NA_real_)           # meno di 2 osservazioni -> NA
1761141934544:x <- df[[col_x]]
1761141934545:y <- df[[col_y]]
1761141934546:# keep only pairs non-NA
1761141934547:ok <- !is.na(x) & !is.na(y)
1761141934548:if (sum(ok) < 2) return(NA_real_)            # meno di 2 coppie valide -> NA
1761141934549:return(cor(x[ok], y[ok], use = "complete.obs"))
1761141934550:}
1761141934801:# Calcola correlazione CRP vs HR per ogni paziente
1761141934804:cor_crp_hr <- data.frame(
1761141934810:patient_id = names(patients_list),
1761141934811:correlation_CRP_HR = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_HR"),
1761141934813:row.names = NULL,
1761141934815:stringsAsFactors = FALSE
1761141934818:)
1761141935008:# Calcola correlazione CRP vs SBP per ogni paziente
1761141935011:cor_crp_sbp <- data.frame(
1761141935013:patient_id = names(patients_list),
1761141935014:correlation_CRP_SBP = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_SBP"),
1761141935016:row.names = NULL,
1761141935017:stringsAsFactors = FALSE
1761141935019:)
1761141939750:# Task 6
1761141939752:bench6 <- microbenchmark(
1761141939754:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761141939756:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761141939758:times = 10
1761141939760:)
1761141940466:autoplot(bench6)
1761141971539:# Task 6
1761141971544:bench6 <- microbenchmark(
1761141971547:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761141971550:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761141971558:times = 10
1761141971561:)
1761143276564:compare_df_dt <- function(df_result, dt_result, tol = 1e-6) {
1761143276568:identical_df <- all.equal(df_result, as.data.frame(dt_result), tolerance = tol)
1761143276570:if (isTRUE(identical_df)) {
1761143276571:message("âœ… Results match between data.frame and data.table versions.")
1761143276573:} else {
1761143276574:warning("âš ï¸ Differences found between DF and DT results.")
1761143276576:print(identical_df)
1761143276577:}
1761143276578:}
1761143289459:View(compare_df_dt)
1761143298516:compare_df_dt <- function(df_result, dt_result, tol = 1e-6) {
1761143298521:identical_df <- all.equal(df_result, as.data.frame(dt_result), tolerance = tol)
1761143298524:if (isTRUE(identical_df)) {
1761143298526:message("âœ… Results match between data.frame and data.table versions.")
1761143298528:} else {
1761143298532:warning("âš ï¸ Differences found between DF and DT results.")
1761143298536:print(identical_df)
1761143298548:}
1761143298551:}
1761143832219:# COMPARATIVE ANALYSIS: data.frame vs data.table
1761143832222:library(data.table)
1761143832224:library(microbenchmark)
1761143832225:library(ggplot2)
1761143832228:# carico le funzioni
1761143832230:source("R/df_functions.R")
1761143832240:source("R/dt_functions.R")
1761143832259:# Task 1
1761143832260:bench1 <- microbenchmark(
1761143832260:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761143832261:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761143832262:times = 10
1761143832263:)
1761143833748:autoplot(bench1)
1761143833986:# Task 2
1761143833987:bench2 <- microbenchmark(
1761143833988:df_version = bulk_counts_qc_df("project_oct25/bulk_counts_long.csv"),
1761143833988:dt_version = bulk_counts_qc_dt("project_oct25/bulk_counts_long.csv"),
1761143833989:times = 10
1761143833990:)
1761143835199:autoplot(bench2)
1761143835444:#Task 3 non ha il benchmark perchÃ¨ ha senso solo in data.table
1761143835445:# Task 4
1761143835446:bench4 <- microbenchmark(
1761143835447:df_version = annotate_counts_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761143835447:dt_version = annotate_counts_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761143835448:times = 10
1761143835449:)
1761143836778:autoplot(bench4)
1761143837012:# Task 5
1761143837012:bench5 <- microbenchmark(
1761143837013:df_version = classify_labs_df("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761143837014:dt_version = classify_labs_dt("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761143837015:times = 10
1761143837015:)
1761143837640:autoplot(bench5)
1761143837905:# Task 6
1761143837905:bench6 <- microbenchmark(
1761143837906:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761143837907:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761143837907:times = 10
1761143837908:)
1761144201507:# ----------------------------------------------------------
1761144201514:# TASK 7 â€“ Compute coefficient of variation (CV)
1761144201519:# ----------------------------------------------------------
1761144201521:top_peaks_df <- function(peaks_path) {
1761144201523:peaks <- read.csv(peaks_path, stringsAsFactors = FALSE)
1761144201526:subset_peaks <- subset(peaks, chr == "chr2" & start >= 2000000 & start <= 4000000)
1761144201528:subset_peaks <- subset_peaks[order(-subset_peaks$score), ]
1761144201532:top50_peaks <- head(subset_peaks, 50)
1761144201536:cat("\n--- Top 50 picchi su chr2 (2â€“4 Mb) ---\n")
1761144201539:print(top50_peaks)
1761144201544:}
1761144212239:# Task 7
1761144212243:bench7 <- microbenchmark(
1761144212244:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv"),
1761144212249:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv"),
1761144212260:times = 10
1761144212261:)
1761144239550:# Task 9
1761144239554:bench9 <- microbenchmark(
1761144239556:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv"),
1761144239557:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv"),
1761144239559:times = 10
1761144239560:)
1761144438085:# Task 9
1761144438089:bench9 <- microbenchmark(
1761144438092:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv,  "project_oct25/sample_metadata.csv"),
1761144658236:# Task 9
1761144658238:bench9 <- microbenchmark(
1761144658240:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761144658241:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761144658242:times = 10
1761144658244:)
1761144666562:# Task 9
1761144666565:bench9 <- microbenchmark(
1761144666567:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761144666569:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761144666571:times = 10
1761144666573:)
1761144963020:library(data.table)
1761144963478:library(microbenchmark)
1761144963818:library(ggplot2)
1761144964823:# carico le funzioni
1761144964825:source("R/df_functions.R")
1761144967656:source("R/dt_functions.R")
1761144972407:# Task 9
1761144972409:bench9 <- microbenchmark(
1761144972411:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761144972413:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761144972414:times = 10
1761144972416:)
1761145746604:# Task 6
1761145746615:bench6 <- microbenchmark(
1761145746622:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761145746624:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761145746625:times = 10
1761145746626:)
1761145833416:# Task 7
1761145833419:bench7 <- microbenchmark(
1761145833420:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv"),
1761145833421:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv"),
1761145833422:times = 10
1761145833424:)
1761230437060:library(data.table)
1761230437065:# ==========================================================
1761230437067:# ðŸ§© TASK 1 â€” Bulk RNA counts summary
1761230437069:# ==========================================================
1761230437073:#' Summarize bulk RNA counts with metadata
1761230437075:#'
1761230437076:#' This function reads in raw bulk RNA-seq counts and metadata,
1761230437076:#' it merges bulk RNA-seq count data with sample metadata by "sample_id",
1761230437077:#' filters treated samples whose gene names start with "GENE_00",
1761230437077:#' and computes multiple summary statistics:
1761230437078:#' mean/median counts per gene as well as per-condition mean counts.
1761230437080:#' Designed for quick quality control and exploratory summaries using data.table's fast aggregation capabilities.
1761230437081:#'
1761230437082:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230437083:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230437084:#' @return List with: filtered_data, gene_mean_median, gene_condition_means
1761230437085:#' \itemize{
1761230437086:#'   \item gene_mean_median: Mean and median counts by gene (treated only)
1761230437086:#'   \item gene_condition_means: Mean counts by gene and condition
1761230437087:#' }
1761230437088:#' @export
1761230437089:bulk_counts_summary_dt <- function(counts_path, meta_path) {
1761230437089:bulk_counts <- fread(counts_path)
1761230437090:sample_meta <- fread(meta_path)
1761230437091:setkey(bulk_counts, sample_id)
1761230437092:setkey(sample_meta, sample_id)
1761230437093:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761230437095:filtered_data <- join_data[condition == "treated" & grepl("^GENE_00", gene)]
1761230437096:gene_mean_median <- filtered_data[, .(
1761230437096:mean_count   = mean(count),
1761230437097:median_count = median(count)
1761230437097:), by = gene]
1761230437098:gene_condition_means <- bulk_counts[
1761230437099:sample_meta,
1761230437100:on = "sample_id"
1761230437100:][ , .(
1761230437101:mean_count = mean(count)
1761230437102:), by = .(gene, condition) ]
1761230437103:return(list(filtered_data = filtered_data, gene_mean_median = gene_mean_median, gene_condition_means = gene_condition_means))
1761230437104:}
1761230437106:# ==========================================================
1761230437106:# ðŸ§© TASK 2 â€” QC-style derived columns
1761230437107:# ==========================================================
1761230437108:#' Add QC-style derived columns (data.table version)
1761230437109:#'
1761230437109:#' Computes log2-transformed counts and adds a binary \code{high} flag
1761230437110:#' indicating whether a count is above the gene-wise median.
1761230437110:#' This mimics typical preprocessing steps in QC pipelines to visualize
1761230437111:#' count distributions and detect outliers.
1761230437112:#'
1761230437112:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230437113:#' @return Data.table with added columns: log2_count, high.
1761230437113:#' @export
1761230437114:bulk_counts_qc_dt <- function(counts_path) {
1761230437114:counts <- fread(counts_path)
1761230437115:counts[, log2_count := log2(count)]
1761230437116:counts[, high := count > 100]
1761230437116:counts[, high := count > median(count), by = gene]
1761230437117:return(counts)
1761230437118:}
1761230437119:# ==========================================================
1761230437119:# ðŸ§© TASK 3 â€” Subset by gene and sample
1761230437120:# ==========================================================
1761230437121:#' Subset counts data using secondary index
1761230437121:#'
1761230437122:#' Joins metadata and benchmarks subsetting by gene and sample with
1761230437122:#' and without secondary indexing â€” useful for optimizing workflows
1761230437123:#' with large RNA-seq tables.
1761230437123:#'
1761230437124:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230437124:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230437125:#' @param gene_name Gene name to subset
1761230437125:#' @param sample_chosen Sample ID to subset
1761230437126:#' @return Subset of counts for the given gene and sample.
1761230437127:#' @export
1761230437127:subset_counts_dt <- function(counts_path, meta_path, gene_call, sample_chosen) {
1761230437128:bulk_counts <- fread(counts_path)
1761230437129:sample_meta <- fread(meta_path)
1761230437130:setkey(sample_meta, sample_id)
1761230437131:join_data <- sample_meta[bulk_counts, on = "sample_id"]
1761230437132:time_no_index <- system.time({
1761230437132:subset_no_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761230437133:})
1761230437134:setindex(bulk_counts, gene, sample_id)
1761230437135:time_with_index <- system.time({
1761230437136:subset_with_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761230437137:})
1761230437138:dt_benchmark <- data.table(
1761230437138:test = c("time_no_index", "time_with_index"),
1761230437139:user = c(time_no_index["user.self"], time_with_index["user.self"]),
1761230437140:system = c(time_no_index["sys.self"], time_with_index["sys.self"]),
1761230437141:elapsed = c(time_no_index["elapsed"], time_with_index["elapsed"])
1761230437141:)
1761230437142:return(dt_benchmark)
1761230437143:}
1761230437144:# ==========================================================
1761230437145:# ðŸ§© TASK 4 â€” Annotate counts and summarize
1761230437145:# ==========================================================
1761230437147:#' Annotate counts with metadata and compute summaries
1761230437147:#'
1761230437148:#' Adds patient metadata to bulk counts, computes per-patient total counts,
1761230437149:#' per-gene means by condition, and identifies top 10 genes per condition
1761230437149:#' ranked by average expression.
1761230437150:#'
1761230437151:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230437151:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230437152:#' @return List with patient totals, and top10 genes.
1761230437152:#' @export
1761230437153:annotate_counts_dt <- function(counts_path, meta_path) {
1761230437154:bulk_counts <- fread(counts_path)
1761230437155:sample_meta <- fread(meta_path)
1761230437157:setkey(bulk_counts, sample_id)
1761230437157:setkey(sample_meta, sample_id)
1761230437158:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761230437160:patient_tot <- join_data[, .(total_count = sum(count)), by = patient_id]
1761230437161:gene_means <- join_data[, .(mean_count = mean(count)), by = .(gene, condition)]
1761230437163:top10 <- gene_means[
1761230437164:order(condition, -mean_count)
1761230437164:][, head(.SD, 10), by = condition]
1761230437166:return(list(patient_tot = patient_tot, top10 = top10))
1761230437166:}
1761230437167:# ==========================================================
1761230437168:# ðŸ§© TASK 5 â€” Classify lab values
1761230437169:# ==========================================================
1761230437170:#' Classify lab values against reference intervals
1761230437171:#'
1761230437171:#' Merges patient lab results with reference intervals and assigns each test
1761230437172:#' as "normal" or "out_of_range", and summarizes abnormalities per patient and per lab.
1761230437173:#'
1761230437173:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761230437174:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761230437174:#' @return List with merged_labs, abnormal_by_patient, abnormal_by_lab.
1761230437175:#' @export
1761230437176:classify_labs_dt <- function(labs_path, ref_path) {
1761230437177:labs <- fread(labs_path)
1761230437177:ref  <- fread(ref_path)
1761230437178:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761230437179:merged_labs <- merge(labs, ref_unique, by = "lab")
1761230437180:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761230437181:abnormal_by_patient <- merged_labs[, .(
1761230437181:total_tests = .N,
1761230437182:out_of_range = sum(status == "out_of_range")
1761230437182:), by = patient_id]
1761230437183:abnormal_by_lab <- merged_labs[, .(
1761230437184:total_tests = .N,
1761230437184:out_of_range = sum(status == "out_of_range")
1761230437185:), by = lab]
1761230437186:return(list(merged_labs = merged_labs, abnormal_by_patient = abnormal_by_patient, abnormal_by_lab = abnormal_by_lab))
1761230437186:}
1761230437188:# ==========================================================
1761230437188:# ðŸ§© TASK 6 â€” Match vitals to labs
1761230437189:# ==========================================================
1761230437190:#' Nearest-time matching of vitals and labs
1761230437190:#'
1761230437191:#' Matches nearest HR/SBP readings, vital signs, to each lab time and computes correlations.
1761230437191:#'
1761230437192:#' Performs "rolling join" to match the closest available heart rate (HR)
1761230437192:#' and systolic blood pressure (SBP) to each lab test times for the same patient.
1761230437193:#' Computes per-patient correlations between CRP (C-reactive protein) and vitals.
1761230437194:#'
1761230437194:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761230437195:#' @param vitals_path Path to CSV file with columns: time_iso
1761230437195:#' @return List with labs_with_vitals and correlations (CRP vs HR/SBP)
1761230437196:#' @export
1761230437196:match_vitals_dt <- function(labs_path, vitals_path) {
1761230437197:labs <- fread(labs_path)
1761230437198:vitals <- fread(vitals_path)
1761230437199:labs[, time_iso := as.POSIXct(time_iso)]
1761230437200:vitals[, time_iso := as.POSIXct(time_iso)]
1761230437201:setorder(labs, patient_id, time_iso)
1761230437201:setorder(vitals, patient_id, time_iso)
1761230437203:labs[, lab_time := time_iso]
1761230437203:setkey(labs, patient_id, time_iso)
1761230437204:setkey(vitals, patient_id, time_iso)
1761230437206:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)]
1761230437206:setnames(vitals_hr, "value", "nearest_HR")
1761230437207:vitals_hr[, hr_time := time_iso]
1761230437208:setkey(vitals_hr, patient_id, time_iso)
1761230437209:labs_with_hr <- vitals_hr[labs, roll = "nearest"]
1761230437210:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761230437211:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761230437212:setnames(vitals_sbp, "value", "nearest_SBP")
1761230437213:vitals_sbp[, sbp_time := time_iso]
1761230437213:setkey(vitals_sbp, patient_id, time_iso)
1761230437214:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761230437215:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761230437217:crp_data <- labs_with_vitals[lab == "CRP"]
1761230437218:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761230437219:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761230437220:), by = patient_id]
1761230437221:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761230437221:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761230437222:), by = patient_id]
1761230437223:return(list(labs_with_hr = labs_with_hr, labs_with_vitals=labs_with_vitals, cor_crp_hr = cor_hr, cor_crp_sbp = cor_sbp))
1761230437224:}
1761230437225:# ==========================================================
1761230437226:# ðŸ§© TASK 7 â€” Top peaks by score
1761230437226:# ==========================================================
1761230437227:#' Extract peaks on chromosome and return top N by score
1761230437228:#'
1761230437228:#' Filters ATAC peaks by chromosome and genomic interval and returns
1761230437229:#' the top 50 by score â€” useful for quick locus-specific exploration.
1761230437229:#'
1761230437230:#' @param peaks_path Path to CSV file with columns:chr, start, end, peak_id, score
1761230437230:#' @param chr_sel selected chromosome string e.g.:"chr2"
1761230437231:#' @param start_min lower bound of range e.g.:2000000
1761230437232:#' @param start_max upper bound of range e.g.:4000000
1761230437233:#' @return Data.table of top peaks
1761230437233:#' @export
1761230437234:top_peaks_dt <- function(peaks_path, chr_path, start_min , start_max) {
1761230437235:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761230437236:subset_peaks <- peaks[chr == chr_sel & start >= start_min & start <= start_max]
1761230437237:subset_peaks <- setorder(subset_peaks, -score)
1761230437238:top50_peaks <- head(subset_peaks, 50)
1761230437239:return(top50_peaks)
1761230437240:}
1761230437241:# ==========================================================
1761230437242:# ðŸ§© TASK 8 â€” Gene stats and filtering
1761230437242:# ==========================================================
1761230437243:#' Compute per-condition gene stas and filter based on fold change.
1761230437244:#'
1761230437245:#' Calculates mean, median, and quartile statistics for each gene under
1761230437245:#' treated and control conditions, then filters genes where the treated
1761230437246:#' mean is at least twice the control mean (treated_mean â‰¥ 2 Ã— control_mean).
1761230437247:#'
1761230437247:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230437248:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230437248:#' @return List with stats_by_gene_condition and kept_genes
1761230437249:#' @export
1761230437250:gene_stats_filter_dt <- function(counts_path, meta_path) {
1761230437250:counts <- fread(counts_path)
1761230437251:meta   <- fread(meta_path)
1761230437252:merged <- counts[meta, on = "sample_id"]
1761230437253:stats_by_gene_condition <- merged[, .(
1761230437253:mean_count   = mean(count),
1761230437254:median_count = median(count),
1761230437254:Q1           = quantile(count, 0.25, type = 2),
1761230437255:Q3           = quantile(count, 0.75, type = 2)
1761230437255:), by = .(gene, condition)]
1761230437256:treated_means <- stats_by_gene_condition[condition == "treated", .(gene, treated_mean = mean_count)]
1761230437257:control_means <- stats_by_gene_condition[condition == "control", .(gene, control_mean = mean_count)]
1761230437258:means_wide <- merge(treated_means, control_means, by = "gene", all = FALSE)
1761230437259:kept_genes <- means_wide[treated_mean >= 2 * control_mean]
1761230437260:return(list(stats_by_gene_condition = stats_by_gene_condition, kept_genes = kept_genes))
1761230437261:}
1761230437262:# ==========================================================
1761230437263:# ðŸ§© TASK 9 â€” Wide â†’ Long â†’ Wide
1761230437263:# ==========================================================
1761230437264:#' Convert wide counts to long and back, computing mean per condition
1761230437265:#'
1761230437265:#'Demonstrates data reshaping with \code{melt()} and \code{dcast()}.
1761230437266:#' Converts wide-format counts (one column per sample) to long format,
1761230437267:#' merges with metadata, computes mean per gene and condition,
1761230437267:#' and returns a condition-wide table again.
1761230437268:#'
1761230437268:#' @param counts_wide_path Path to CSV file with columns genes and samples
1761230437269:#' @return Data.table wide by condition with mean counts
1761230437270:#' @export
1761230437271:wide_long_wide_dt <- function(counts_wide_path, meta_path) {
1761230437272:counts_wide <- fread(counts_wide_path)
1761230437273:counts_long <- melt(counts_wide, id.vars = "gene",
1761230437273:variable.name = "sample_id", value.name = "count")
1761230437274:meta <- fread(meta_path)
1761230437275:merged <- merge(counts_long, meta, by = "sample_id")
1761230437276:totals_per_sample <- merged[, .(total_count = sum(count)), by = sample_id]
1761230437277:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761230437278:gene_condition_means <- merged[, .(mean_count = mean(count)),
1761230437279:by = .(gene, condition)]
1761230437280:counts_condition_wide <- dcast(gene_condition_means,
1761230437280:gene ~ condition,
1761230437281:value.var = "mean_count")
1761230437281:return(counts_condition_wide)
1761230437282:}
1761230437283:# ==========================================================
1761230437283:# ðŸ§© TASK 10 â€” ATAC peaks to genes
1761230437284:# ==========================================================
1761230437285:#' Map ATAC-seq peaks to genes using genomic overlaps
1761230437285:#'
1761230437286:#' Uses \code{foverlaps()} to detect overlaps between peak intervals
1761230437286:#' and gene coordinates, computes overlap lengths, and summarizes
1761230437287:#' peaks per gene and total overlap length. Returns top 20 genes
1761230437287:#' with the most total overlapping base pairs.
1761230437288:#'
1761230437288:#' @param peaks_path Path to CSV file with columns: chr, start, end, peak_id, score
1761230437289:#' @param genes_path Path to CSV file with columns: chr, start, end, gene
1761230437289:#' @return List with overlap tables, peaks_per_gene and top 20 genes by overlap
1761230437290:#' @export
1761230437291:atac_to_gene_dt <- function(peaks_path, genes_path) {
1761230437292:peaks <- fread(peaks_path)
1761230437292:genes <- fread(genes_path)
1761230437293:setkey(peaks, chr, start, end)
1761230437294:setkey(genes, chr, start, end)
1761230437295:overlaps <- foverlaps(peaks, genes,
1761230437295:by.x = c("chr", "start", "end"),
1761230437296:by.y = c("chr", "start", "end"),
1761230437296:type = "any", nomatch = 0L)
1761230437297:overlaps[, overlap_bp := pmin(end, i.end) - pmax(start, i.start)]
1761230437299:overlaps <- overlaps[overlap_bp > 0]
1761230437300:peaks_per_gene <- overlaps[, .N, by = gene]
1761230437300:setnames(peaks_per_gene, "N", "num_peaks")
1761230437301:overlap_sum_per_gene <- overlaps[, .(total_overlap_bp = sum(overlap_bp)), by = gene]
1761230437303:top20_genes <- overlap_sum_per_gene[order(-total_overlap_bp)][1:20]
1761230437303:return(list(overlaps=overlaps, peaks_per_gene=peaks_per_gene, top20_genes=top20_genes))
1761230437304:}
1761230437305:# ==========================================================
1761230437306:# ðŸ§© TASK 11 â€” Variants to genes
1761230437306:# ==========================================================
1761230437307:#' Map genetic variants to genes and count HIGH-impact variants
1761230437308:#'
1761230437308:#' Performs overlap join between variant coordinates and gene annotations,
1761230437309:#' counts variants per gene, and identifies genes with HIGH-impact variants.
1761230437309:#'
1761230437310:#' @param variants_path  Path to CSV file with columns: sample_id, chr, pos, ref, alt, impact
1761230437310:#' @param genes_path  Path to CSV file with columns: chr, start, end, gene
1761230437311:#' @return List with counts and high-impact genes
1761230437311:#' @export
1761230437312:variants_to_genes_dt <- function(variants_path, genes_path) {
1761230437313:variants <- fread(variants_path)
1761230437313:genes    <- fread(genes_path)
1761230437314:variants[, start := pos]  #creo per ogni variante un intervallo 1bp
1761230437315:variants[, end   := pos]  #foverlaps () lavora con intervalli start-end quindi gli servono
1761230437316:setkey(variants, chr, start, end)
1761230437316:setkey(genes,    chr, start, end)
1761230437317:overlaps <- foverlaps(variants, genes, type = "any", nomatch = 0L)
1761230437318:overlaps[, impact_upper := toupper(impact)]
1761230437319:high_overlaps <- overlaps[impact_upper == "HIGH"]
1761230437321:high_counts_by_gene_sample <- high_overlaps[, .(
1761230437321:high_variant_count = .N
1761230437322:), by = .(gene, sample_id)]
1761230437324:high_counts_by_gene <- high_overlaps[, .(
1761230437324:total_high_variants = .N
1761230437325:), by = gene][order(-total_high_variants)]
1761230437326:genes_with_high <- unique(high_counts_by_gene$gene)
1761230437327:return(list(overlaps=overlaps, genes_with_high = genes_with_high))
1761230437328:}
1761230437329:# ==========================================================
1761230437329:# ðŸ§© TASK 12 â€” Combine cohorts
1761230437330:# ==========================================================
1761230437331:#' Combine cohorts safely and compute variability summaries
1761230437332:#'
1761230437332:#' This function merges two cohort-level sample metadata tables
1761230437333:#' and joins them to a long-format RNA-seq counts table to perform a per-cohort, per-condition
1761230437333:#' expression summary of the most 100 variable genes.
1761230437334:#'
1761230437334:#' @param cohortA_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761230437335:#' @param cohortB_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761230437335:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230437336:#' @return List with combined cohort info and top genes
1761230437336:#' @export
1761230437337:combine_cohorts_dt <- function(cohortA_path, cohortB_path, counts_path) {
1761230437338:cohortA <- fread(cohortA_path)
1761230437339:cohortB <- fread(cohortB_path)
1761230437339:counts  <- fread(counts_path)
1761230437340:cohortA[, cohort := "A"]
1761230437341:cohortB[, cohort := "B"]
1761230437342:combined_cohorts <- rbindlist(list(cohortA, cohortB), use.names = TRUE, fill = TRUE)
1761230437343:setorder(combined_cohorts, cohort, condition, sample_id)
1761230437344:merged_per_sampleid <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761230437345:gene_variance <- merged_per_sampleid[, .(variance = var(count, na.rm = TRUE)), by = gene]
1761230437346:top100_genes <- gene_variance[order(-variance)][1:100, gene]
1761230437347:top100_data <- merged_per_sampleid[gene %in% top100_genes]
1761230437348:mean_counts <- top100_data[, .(
1761230437348:mean_count = mean(count, na.rm = TRUE)
1761230437349:), by = .(gene, cohort, condition)]
1761230437350:return(top100_data)
1761230437351:}
1761230437352:# ==========================================================
1761230437353:# ðŸ§© FINAL REVISION TASKS (1.1 â†’ 5.1)
1761230437353:# ==========================================================
1761230437354:#' Combine integration and clustering data
1761230437355:#'
1761230437355:#' Reads and merges integration and clustering tables by cell ID, ensuring consistent ID formatting.
1761230437356:#'
1761230437356:#' @export
1761230437357:combine_integration_clustering_dt <- function(integration_file, clustering_file) {
1761230437357:int <- fread(integration_file)
1761230437358:clu <- fread(clustering_file)
1761230437358:normalize <- function(x) gsub("_X_|_Y_", "_", trimws(as.character(x)))
1761230437359:int[, cell_clean := normalize(cell)]
1761230437360:clu[, cell_clean := normalize(cell)]
1761230437361:merge(int, clu, by = "cell_clean", all = FALSE)
1761230437361:}
1761230437362:#' Count cells per cluster and cell type
1761230437363:#' @export
1761230437363:count_cells_per_cluster_dt <- function(combined_dt) {
1761230437364:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type)]
1761230437364:setnames(counts, "N", "cell_count")
1761230437365:counts
1761230437365:}
1761230437366:#' Count cells per cluster, cell type, and sample type
1761230437367:#' @export
1761230437367:add_sample_type_dt <- function(combined_dt) {
1761230437368:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type, sample_type)]
1761230437369:setnames(counts, "N", "cell_count")
1761230437370:counts
1761230437370:}
1761230437371:#' Compute total cell counts per cluster and sample type
1761230437372:#' @export
1761230437372:compute_totals_dt <- function(counts_dt) {
1761230437373:counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761230437373:}
1761230437374:#' Compute normalized percentages per cluster and tissue
1761230437375:#' @export
1761230437375:compute_percentages_dt <- function(counts_dt) {
1761230437376:totals <- counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761230437376:merged <- merge(counts_dt, totals, by = c("integration_cluster", "sample_type"))
1761230437377:merged[, percent := round((cell_count / total_cells) * 100, 2)]
1761230437378:merged[order(integration_cluster)]
1761230437379:}
1761230454160:devtools::document()
1761230464717:devtools::load_all()
1761230480680:?top_peaks_dt
1761230505467:?bulk_counts_qc_dt
1761230525873:library(data.table)
1761230525879:# ==========================================================
1761230525881:# ðŸ§© TASK 1 â€” Bulk RNA counts summary
1761230525883:# ==========================================================
1761230525887:#' Summarize bulk RNA counts with metadata
1761230525888:#'
1761230525889:#' This function reads in raw bulk RNA-seq counts and metadata,
1761230525890:#' it merges bulk RNA-seq count data with sample metadata by "sample_id",
1761230525890:#' filters treated samples whose gene names start with "GENE_00",
1761230525891:#' and computes multiple summary statistics:
1761230525892:#' mean/median counts per gene as well as per-condition mean counts.
1761230525893:#' Designed for quick quality control and exploratory summaries using data.table's fast aggregation capabilities.
1761230525894:#'
1761230525894:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230525895:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230525896:#' @return List with: filtered_data, gene_mean_median, gene_condition_means
1761230525897:#' \itemize{
1761230525897:#'   \item gene_mean_median: Mean and median counts by gene (treated only)
1761230525898:#'   \item gene_condition_means: Mean counts by gene and condition
1761230525899:#' }
1761230525900:#' @export
1761230525901:bulk_counts_summary_dt <- function(counts_path, meta_path) {
1761230525902:bulk_counts <- fread(counts_path)
1761230525903:sample_meta <- fread(meta_path)
1761230525904:setkey(bulk_counts, sample_id)
1761230525906:setkey(sample_meta, sample_id)
1761230525908:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761230525909:filtered_data <- join_data[condition == "treated" & grepl("^GENE_00", gene)]
1761230525910:gene_mean_median <- filtered_data[, .(
1761230525911:mean_count   = mean(count),
1761230525912:median_count = median(count)
1761230525913:), by = gene]
1761230525914:gene_condition_means <- bulk_counts[
1761230525914:sample_meta,
1761230525915:on = "sample_id"
1761230525916:][ , .(
1761230525916:mean_count = mean(count)
1761230525917:), by = .(gene, condition) ]
1761230525918:return(list(filtered_data = filtered_data, gene_mean_median = gene_mean_median, gene_condition_means = gene_condition_means))
1761230525919:}
1761230525921:# ==========================================================
1761230525921:# ðŸ§© TASK 2 â€” QC-style derived columns
1761230525922:# ==========================================================
1761230525923:#' Add QC-style derived columns
1761230525924:#'
1761230525925:#' Computes log2-transformed counts and adds a binary \code{high} flag
1761230525926:#' indicating whether a count is above the gene-wise median.
1761230525926:#' This mimics typical preprocessing steps in QC pipelines to visualize
1761230525927:#' count distributions and detect outliers.
1761230525927:#'
1761230525928:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230525929:#' @return Data.table with added columns: log2_count, high.
1761230525929:#' @export
1761230525930:bulk_counts_qc_dt <- function(counts_path) {
1761230525931:counts <- fread(counts_path)
1761230525931:counts[, log2_count := log2(count)]
1761230525932:counts[, high := count > 100]
1761230525932:counts[, high := count > median(count), by = gene]
1761230525934:return(counts)
1761230525934:}
1761230525936:# ==========================================================
1761230525936:# ðŸ§© TASK 3 â€” Subset by gene and sample
1761230525937:# ==========================================================
1761230525938:#' Subset counts data using secondary index
1761230525938:#'
1761230525939:#' Joins metadata and benchmarks subsetting by gene and sample with
1761230525939:#' and without secondary indexing â€” useful for optimizing workflows
1761230525940:#' with large RNA-seq tables.
1761230525941:#'
1761230525941:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230525942:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230525943:#' @param gene_name Gene name to subset
1761230525943:#' @param sample_chosen Sample ID to subset
1761230525944:#' @return Subset of counts for the given gene and sample.
1761230525944:#' @export
1761230525945:subset_counts_dt <- function(counts_path, meta_path, gene_call, sample_chosen) {
1761230525945:bulk_counts <- fread(counts_path)
1761230525946:sample_meta <- fread(meta_path)
1761230525947:setkey(sample_meta, sample_id)
1761230525948:join_data <- sample_meta[bulk_counts, on = "sample_id"]
1761230525949:time_no_index <- system.time({
1761230525949:subset_no_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761230525950:})
1761230525951:setindex(bulk_counts, gene, sample_id)
1761230525952:time_with_index <- system.time({
1761230525953:subset_with_index <- bulk_counts[gene == gene_call & sample_id == sample_chosen]
1761230525954:})
1761230525955:dt_benchmark <- data.table(
1761230525955:test = c("time_no_index", "time_with_index"),
1761230525956:user = c(time_no_index["user.self"], time_with_index["user.self"]),
1761230525957:system = c(time_no_index["sys.self"], time_with_index["sys.self"]),
1761230525957:elapsed = c(time_no_index["elapsed"], time_with_index["elapsed"])
1761230525958:)
1761230525959:return(dt_benchmark)
1761230525960:}
1761230525962:# ==========================================================
1761230525962:# ðŸ§© TASK 4 â€” Annotate counts and summarize
1761230525963:# ==========================================================
1761230525964:#' Annotate counts with metadata and compute summaries
1761230525964:#'
1761230525965:#' Adds patient metadata to bulk counts, computes per-patient total counts,
1761230525965:#' per-gene means by condition, and identifies top 10 genes per condition
1761230525966:#' ranked by average expression.
1761230525966:#'
1761230525967:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230525967:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230525968:#' @return List with patient totals, and top10 genes.
1761230525968:#' @export
1761230525969:annotate_counts_dt <- function(counts_path, meta_path) {
1761230525970:bulk_counts <- fread(counts_path)
1761230525970:sample_meta <- fread(meta_path)
1761230525972:setkey(bulk_counts, sample_id)
1761230525972:setkey(sample_meta, sample_id)
1761230525973:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761230525974:patient_tot <- join_data[, .(total_count = sum(count)), by = patient_id]
1761230525975:gene_means <- join_data[, .(mean_count = mean(count)), by = .(gene, condition)]
1761230525977:top10 <- gene_means[
1761230525977:order(condition, -mean_count)
1761230525978:][, head(.SD, 10), by = condition]
1761230525979:return(list(patient_tot = patient_tot, top10 = top10))
1761230525980:}
1761230525981:# ==========================================================
1761230525981:# ðŸ§© TASK 5 â€” Classify lab values
1761230525982:# ==========================================================
1761230525983:#' Classify lab values against reference intervals
1761230525983:#'
1761230525984:#' Merges patient lab results with reference intervals and assigns each test
1761230525984:#' as "normal" or "out_of_range", and summarizes abnormalities per patient and per lab.
1761230525985:#'
1761230525985:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761230525986:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761230525986:#' @return List with merged_labs, abnormal_by_patient, abnormal_by_lab.
1761230525987:#' @export
1761230525987:classify_labs_dt <- function(labs_path, ref_path) {
1761230525988:labs <- fread(labs_path)
1761230525989:ref  <- fread(ref_path)
1761230525990:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761230525991:merged_labs <- merge(labs, ref_unique, by = "lab")
1761230525992:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761230525993:abnormal_by_patient <- merged_labs[, .(
1761230525994:total_tests = .N,
1761230525995:out_of_range = sum(status == "out_of_range")
1761230525995:), by = patient_id]
1761230525996:abnormal_by_lab <- merged_labs[, .(
1761230525997:total_tests = .N,
1761230525997:out_of_range = sum(status == "out_of_range")
1761230525998:), by = lab]
1761230525999:return(list(merged_labs = merged_labs, abnormal_by_patient = abnormal_by_patient, abnormal_by_lab = abnormal_by_lab))
1761230526000:}
1761230526001:# ==========================================================
1761230526002:# ðŸ§© TASK 6 â€” Match vitals to labs
1761230526002:# ==========================================================
1761230526003:#' Nearest-time matching of vitals and labs
1761230526004:#'
1761230526004:#' Matches nearest HR/SBP readings, vital signs, to each lab time and computes correlations.
1761230526005:#'
1761230526005:#' Performs "rolling join" to match the closest available heart rate (HR)
1761230526006:#' and systolic blood pressure (SBP) to each lab test times for the same patient.
1761230526006:#' Computes per-patient correlations between CRP (C-reactive protein) and vitals.
1761230526007:#'
1761230526008:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761230526008:#' @param vitals_path Path to CSV file with columns: time_iso
1761230526009:#' @return List with labs_with_vitals and correlations (CRP vs HR/SBP)
1761230526009:#' @export
1761230526010:match_vitals_dt <- function(labs_path, vitals_path) {
1761230526011:labs <- fread(labs_path)
1761230526011:vitals <- fread(vitals_path)
1761230526012:labs[, time_iso := as.POSIXct(time_iso)]
1761230526013:vitals[, time_iso := as.POSIXct(time_iso)]
1761230526014:setorder(labs, patient_id, time_iso)
1761230526014:setorder(vitals, patient_id, time_iso)
1761230526016:labs[, lab_time := time_iso]
1761230526016:setkey(labs, patient_id, time_iso)
1761230526017:setkey(vitals, patient_id, time_iso)
1761230526018:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)]
1761230526019:setnames(vitals_hr, "value", "nearest_HR")
1761230526020:vitals_hr[, hr_time := time_iso]
1761230526020:setkey(vitals_hr, patient_id, time_iso)
1761230526022:labs_with_hr <- vitals_hr[labs, roll = "nearest"]
1761230526023:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761230526024:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761230526024:setnames(vitals_sbp, "value", "nearest_SBP")
1761230526025:vitals_sbp[, sbp_time := time_iso]
1761230526026:setkey(vitals_sbp, patient_id, time_iso)
1761230526027:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761230526028:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761230526029:crp_data <- labs_with_vitals[lab == "CRP"]
1761230526032:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761230526032:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761230526033:), by = patient_id]
1761230526034:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761230526035:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761230526035:), by = patient_id]
1761230526037:return(list(labs_with_hr = labs_with_hr, labs_with_vitals=labs_with_vitals, cor_crp_hr = cor_hr, cor_crp_sbp = cor_sbp))
1761230526037:}
1761230526039:# ==========================================================
1761230526039:# ðŸ§© TASK 7 â€” Top peaks by score
1761230526040:# ==========================================================
1761230526041:#' Extract peaks on chromosome and return top N by score
1761230526041:#'
1761230526042:#' Filters ATAC peaks by chromosome and genomic interval and returns
1761230526042:#' the top 50 by score â€” useful for quick locus-specific exploration.
1761230526043:#'
1761230526043:#' @param peaks_path Path to CSV file with columns:chr, start, end, peak_id, score
1761230526044:#' @param chr_sel selected chromosome string e.g.:"chr2"
1761230526044:#' @param start_min lower bound of range e.g.:2000000
1761230526045:#' @param start_max upper bound of range e.g.:4000000
1761230526045:#' @return Data.table of top peaks
1761230526046:#' @export
1761230526046:top_peaks_dt <- function(peaks_path, chr_path, start_min , start_max) {
1761230526047:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761230526048:subset_peaks <- peaks[chr == chr_sel & start >= start_min & start <= start_max]
1761230526049:subset_peaks <- setorder(subset_peaks, -score)
1761230526050:top50_peaks <- head(subset_peaks, 50)
1761230526051:return(top50_peaks)
1761230526052:}
1761230526053:# ==========================================================
1761230526053:# ðŸ§© TASK 8 â€” Gene stats and filtering
1761230526054:# ==========================================================
1761230526055:#' Compute per-condition gene stas and filter based on fold change.
1761230526055:#'
1761230526056:#' Calculates mean, median, and quartile statistics for each gene under
1761230526056:#' treated and control conditions, then filters genes where the treated
1761230526057:#' mean is at least twice the control mean (treated_mean â‰¥ 2 Ã— control_mean).
1761230526057:#'
1761230526058:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230526058:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761230526059:#' @return List with stats_by_gene_condition and kept_genes
1761230526059:#' @export
1761230526060:gene_stats_filter_dt <- function(counts_path, meta_path) {
1761230526061:counts <- fread(counts_path)
1761230526061:meta   <- fread(meta_path)
1761230526062:merged <- counts[meta, on = "sample_id"]
1761230526064:stats_by_gene_condition <- merged[, .(
1761230526064:mean_count   = mean(count),
1761230526065:median_count = median(count),
1761230526065:Q1           = quantile(count, 0.25, type = 2),
1761230526066:Q3           = quantile(count, 0.75, type = 2)
1761230526067:), by = .(gene, condition)]
1761230526068:treated_means <- stats_by_gene_condition[condition == "treated", .(gene, treated_mean = mean_count)]
1761230526068:control_means <- stats_by_gene_condition[condition == "control", .(gene, control_mean = mean_count)]
1761230526069:means_wide <- merge(treated_means, control_means, by = "gene", all = FALSE)
1761230526070:kept_genes <- means_wide[treated_mean >= 2 * control_mean]
1761230526072:return(list(stats_by_gene_condition = stats_by_gene_condition, kept_genes = kept_genes))
1761230526072:}
1761230526073:# ==========================================================
1761230526074:# ðŸ§© TASK 9 â€” Wide â†’ Long â†’ Wide
1761230526074:# ==========================================================
1761230526075:#' Convert wide counts to long and back, computing mean per condition
1761230526076:#'
1761230526076:#'Demonstrates data reshaping with \code{melt()} and \code{dcast()}.
1761230526077:#' Converts wide-format counts (one column per sample) to long format,
1761230526077:#' merges with metadata, computes mean per gene and condition,
1761230526078:#' and returns a condition-wide table again.
1761230526079:#'
1761230526079:#' @param counts_wide_path Path to CSV file with columns genes and samples
1761230526080:#' @return Data.table wide by condition with mean counts
1761230526080:#' @export
1761230526081:wide_long_wide_dt <- function(counts_wide_path, meta_path) {
1761230526082:counts_wide <- fread(counts_wide_path)
1761230526083:counts_long <- melt(counts_wide, id.vars = "gene",
1761230526084:variable.name = "sample_id", value.name = "count")
1761230526085:meta <- fread(meta_path)
1761230526086:merged <- merge(counts_long, meta, by = "sample_id")
1761230526087:totals_per_sample <- merged[, .(total_count = sum(count)), by = sample_id]
1761230526088:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761230526089:gene_condition_means <- merged[, .(mean_count = mean(count)),
1761230526089:by = .(gene, condition)]
1761230526090:counts_condition_wide <- dcast(gene_condition_means,
1761230526091:gene ~ condition,
1761230526092:value.var = "mean_count")
1761230526092:return(counts_condition_wide)
1761230526093:}
1761230526094:# ==========================================================
1761230526095:# ðŸ§© TASK 10 â€” ATAC peaks to genes
1761230526096:# ==========================================================
1761230526097:#' Map ATAC-seq peaks to genes using genomic overlaps
1761230526097:#'
1761230526098:#' Uses \code{foverlaps()} to detect overlaps between peak intervals
1761230526098:#' and gene coordinates, computes overlap lengths, and summarizes
1761230526099:#' peaks per gene and total overlap length. Returns top 20 genes
1761230526099:#' with the most total overlapping base pairs.
1761230526100:#'
1761230526100:#' @param peaks_path Path to CSV file with columns: chr, start, end, peak_id, score
1761230526101:#' @param genes_path Path to CSV file with columns: chr, start, end, gene
1761230526102:#' @return List with overlap tables, peaks_per_gene and top 20 genes by overlap
1761230526102:#' @export
1761230526103:atac_to_gene_dt <- function(peaks_path, genes_path) {
1761230526104:peaks <- fread(peaks_path)
1761230526105:genes <- fread(genes_path)
1761230526106:setkey(peaks, chr, start, end)
1761230526106:setkey(genes, chr, start, end)
1761230526107:overlaps <- foverlaps(peaks, genes,
1761230526108:by.x = c("chr", "start", "end"),
1761230526109:by.y = c("chr", "start", "end"),
1761230526109:type = "any", nomatch = 0L)
1761230526110:overlaps[, overlap_bp := pmin(end, i.end) - pmax(start, i.start)]
1761230526111:overlaps <- overlaps[overlap_bp > 0]
1761230526112:peaks_per_gene <- overlaps[, .N, by = gene]
1761230526113:setnames(peaks_per_gene, "N", "num_peaks")
1761230526114:overlap_sum_per_gene <- overlaps[, .(total_overlap_bp = sum(overlap_bp)), by = gene]
1761230526115:top20_genes <- overlap_sum_per_gene[order(-total_overlap_bp)][1:20]
1761230526116:return(list(overlaps=overlaps, peaks_per_gene=peaks_per_gene, top20_genes=top20_genes))
1761230526117:}
1761230526118:# ==========================================================
1761230526119:# ðŸ§© TASK 11 â€” Variants to genes
1761230526119:# ==========================================================
1761230526121:#' Map genetic variants to genes and count HIGH-impact variants
1761230526121:#'
1761230526122:#' Performs overlap join between variant coordinates and gene annotations,
1761230526123:#' counts variants per gene, and identifies genes with HIGH-impact variants.
1761230526123:#'
1761230526124:#' @param variants_path  Path to CSV file with columns: sample_id, chr, pos, ref, alt, impact
1761230526124:#' @param genes_path  Path to CSV file with columns: chr, start, end, gene
1761230526125:#' @return List with counts and high-impact genes
1761230526125:#' @export
1761230526126:variants_to_genes_dt <- function(variants_path, genes_path) {
1761230526127:variants <- fread(variants_path)
1761230526128:genes    <- fread(genes_path)
1761230526129:variants[, start := pos]  #creo per ogni variante un intervallo 1bp
1761230526129:variants[, end   := pos]  #foverlaps () lavora con intervalli start-end quindi gli servono
1761230526131:setkey(variants, chr, start, end)
1761230526131:setkey(genes,    chr, start, end)
1761230526132:overlaps <- foverlaps(variants, genes, type = "any", nomatch = 0L)
1761230526133:overlaps[, impact_upper := toupper(impact)]
1761230526134:high_overlaps <- overlaps[impact_upper == "HIGH"]
1761230526136:high_counts_by_gene_sample <- high_overlaps[, .(
1761230526136:high_variant_count = .N
1761230526137:), by = .(gene, sample_id)]
1761230526138:high_counts_by_gene <- high_overlaps[, .(
1761230526139:total_high_variants = .N
1761230526140:), by = gene][order(-total_high_variants)]
1761230526142:genes_with_high <- unique(high_counts_by_gene$gene)
1761230526142:return(list(overlaps=overlaps, genes_with_high = genes_with_high))
1761230526143:}
1761230526144:# ==========================================================
1761230526145:# ðŸ§© TASK 12 â€” Combine cohorts
1761230526145:# ==========================================================
1761230526146:#' Combine cohorts safely and compute variability summaries
1761230526147:#'
1761230526147:#' This function merges two cohort-level sample metadata tables
1761230526148:#' and joins them to a long-format RNA-seq counts table to perform a per-cohort, per-condition
1761230526148:#' expression summary of the most 100 variable genes.
1761230526149:#'
1761230526149:#' @param cohortA_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761230526150:#' @param cohortB_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761230526150:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761230526151:#' @return List with combined cohort info and top genes
1761230526151:#' @export
1761230526152:combine_cohorts_dt <- function(cohortA_path, cohortB_path, counts_path) {
1761230526153:cohortA <- fread(cohortA_path)
1761230526154:cohortB <- fread(cohortB_path)
1761230526154:counts  <- fread(counts_path)
1761230526156:cohortA[, cohort := "A"]
1761230526156:cohortB[, cohort := "B"]
1761230526157:combined_cohorts <- rbindlist(list(cohortA, cohortB), use.names = TRUE, fill = TRUE)
1761230526158:setorder(combined_cohorts, cohort, condition, sample_id)
1761230526159:merged_per_sampleid <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761230526161:gene_variance <- merged_per_sampleid[, .(variance = var(count, na.rm = TRUE)), by = gene]
1761230526162:top100_genes <- gene_variance[order(-variance)][1:100, gene]
1761230526164:top100_data <- merged_per_sampleid[gene %in% top100_genes]
1761230526165:mean_counts <- top100_data[, .(
1761230526165:mean_count = mean(count, na.rm = TRUE)
1761230526166:), by = .(gene, cohort, condition)]
1761230526167:return(top100_data)
1761230526168:}
1761230526170:# ==========================================================
1761230526170:# ðŸ§© FINAL REVISION TASKS (1.1 â†’ 5.1)
1761230526171:# ==========================================================
1761230526172:#' Combine integration and clustering data
1761230526173:#'
1761230526173:#' Reads and merges integration and clustering tables by cell ID, ensuring consistent ID formatting.
1761230526174:#'
1761230526175:#' @export
1761230526175:combine_integration_clustering_dt <- function(integration_file, clustering_file) {
1761230526176:int <- fread(integration_file)
1761230526176:clu <- fread(clustering_file)
1761230526177:normalize <- function(x) gsub("_X_|_Y_", "_", trimws(as.character(x)))
1761230526178:int[, cell_clean := normalize(cell)]
1761230526178:clu[, cell_clean := normalize(cell)]
1761230526179:merge(int, clu, by = "cell_clean", all = FALSE)
1761230526179:}
1761230526180:#' Count cells per cluster and cell type
1761230526181:#' @export
1761230526182:count_cells_per_cluster_dt <- function(combined_dt) {
1761230526183:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type)]
1761230526184:setnames(counts, "N", "cell_count")
1761230526184:counts
1761230526186:}
1761230526187:#' Count cells per cluster, cell type, and sample type
1761230526188:#' @export
1761230526189:add_sample_type_dt <- function(combined_dt) {
1761230526190:counts <- combined_dt[, .N, by = .(integration_cluster, cell_type, sample_type)]
1761230526191:setnames(counts, "N", "cell_count")
1761230526192:counts
1761230526196:}
1761230526198:#' Compute total cell counts per cluster and sample type
1761230526199:#' @export
1761230526199:compute_totals_dt <- function(counts_dt) {
1761230526200:counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761230526201:}
1761230526202:#' Compute normalized percentages per cluster and tissue
1761230526202:#' @export
1761230526203:compute_percentages_dt <- function(counts_dt) {
1761230526204:totals <- counts_dt[, .(total_cells = sum(cell_count)), by = .(integration_cluster, sample_type)]
1761230526204:merged <- merge(counts_dt, totals, by = c("integration_cluster", "sample_type"))
1761230526205:merged[, percent := round((cell_count / total_cells) * 100, 2)]
1761230526205:merged[order(integration_cluster)]
1761230526206:}
1761230542066:devtools::document()
1761230548515:devtools::load_all()
1761230557084:library(data.table)
1761230558127:library(microbenchmark)
1761230558706:library(ggplot2)
1761230559305:# carico le funzioni
1761230559309:source("R/df_functions.R")
1761230560990:source("R/dt_functions.R")
1761230562268:# Task 1
1761230562272:bench1 <- microbenchmark(
1761230562273:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761230562275:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761230562277:times = 10
1761230562282:)
1761230564035:autoplot(bench1)
1761230567300:# Task 2
1761230567304:bench2 <- microbenchmark(
1761230567305:df_version = bulk_counts_qc_df("project_oct25/bulk_counts_long.csv"),
1761230567306:dt_version = bulk_counts_qc_dt("project_oct25/bulk_counts_long.csv"),
1761230567308:times = 10
1761230567309:)
1761230569834:autoplot(bench2)
1761230570651:# Task 4
1761230570653:bench4 <- microbenchmark(
1761230570658:df_version = annotate_counts_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761230570659:dt_version = annotate_counts_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761230570661:times = 10
1761230570662:)
1761230572020:autoplot(bench4)
1761230573269:# Task 5
1761230573271:bench5 <- microbenchmark(
1761230573275:df_version = classify_labs_df("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761230573278:dt_version = classify_labs_dt("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761230573282:times = 10
1761230573286:)
1761230574584:autoplot(bench5)
1761230575764:# Task 6
1761230575768:bench6 <- microbenchmark(
1761230575769:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761230575771:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761230575772:times = 10
1761230575773:)
1761230627581:autoplot(bench6)
1761230628704:# Task 7
1761230628709:bench7 <- microbenchmark(
1761230628711:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv"),
1761230628712:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv"),
1761230628714:times = 10
1761230628716:)
1761230630083:autoplot(bench7)
1761230631380:# Task 8
1761230631384:bench8 <- microbenchmark(
1761230631385:df_version = gene_stats_filter_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761230631387:dt_version = gene_stats_filter_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761230631388:times = 10
1761230631389:)
1761230642028:autoplot(bench8)
1761230642285:# Task 9
1761230642285:bench9 <- microbenchmark(
1761230642286:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761230642286:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761230642287:times = 10
1761230642288:)
1761230644355:autoplot(bench9)
1761230644656:# Task 10
1761230644657:bench10 <- microbenchmark(
1761230644658:df_version = atac_to_gene_df("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761230644659:dt_version = atac_to_gene_dt("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761230644660:times = 10
1761230644661:)
1761230665975:autoplot(bench10)
1761230666289:# Task 11
1761230666290:bench11 <- microbenchmark(
1761230666290:df_version = variants_to_genes_df("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761230666291:dt_version = variants_to_genes_dt("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761230666292:times = 10
1761230666293:)
1761230674257:autoplot(bench11)
1761230674591:# Task 12
1761230674591:bench12 <- microbenchmark(
1761230674593:df_version = combine_cohorts_df("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761230674595:dt_version = combine_cohorts_dt("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761230674596:times = 10
1761230674596:)
1761230676155:autoplot(bench12)
1761556351203:library(data.table)
1761556352171:library(microbenchmark)
1761556352778:library(ggplot2)
1761556353465:# carico le funzioni
1761556353473:source("R/df_functions.R")
1761556354130:source("R/dt_functions.R")
1761556355416:# Task 1
1761556355419:bench1 <- microbenchmark(
1761556355420:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761556355421:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761556355423:times = 10
1761556355424:)
1761556356810:autoplot(bench1)
1761556358558:# Task 2
1761556358562:bench2 <- microbenchmark(
1761556358568:df_version = bulk_counts_qc_df("project_oct25/bulk_counts_long.csv"),
1761556358571:dt_version = bulk_counts_qc_dt("project_oct25/bulk_counts_long.csv"),
1761556358573:times = 10
1761556358575:)
1761556360705:autoplot(bench2)
1761556362773:# Task 4
1761556362775:bench4 <- microbenchmark(
1761556362777:df_version = annotate_counts_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761556362778:dt_version = annotate_counts_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761556362780:times = 10
1761556362781:)
1761556365780:autoplot(bench4)
1761556369405:# Task 5
1761556369408:bench5 <- microbenchmark(
1761556369409:df_version = classify_labs_df("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761556369410:dt_version = classify_labs_dt("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761556369411:times = 10
1761556369412:)
1761556371554:autoplot(bench5)
1761556374802:# Task 6
1761556374805:bench6 <- microbenchmark(
1761556374806:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556374807:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556374808:times = 10
1761556374809:)
1761556624672:file.exists("project_oct25/vitals_time_series.csv")
1761556714074:library(data.table)
1761556714586:library(microbenchmark)
1761556715184:library(ggplot2)
1761556719153:# Task 6
1761556719156:bench6 <- microbenchmark(
1761556719157:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556719158:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556719159:times = 10
1761556719160:)
1761556739257:# carico le funzioni
1761556739261:source("R/df_functions.R")
1761556739695:source("R/dt_functions.R")
1761556743301:# Task 6
1761556743304:bench6 <- microbenchmark(
1761556743306:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556743307:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556743310:times = 10
1761556743312:)
1761556751699:autoplot(bench6)
1761556754260:# Task 7
1761556754262:bench7 <- microbenchmark(
1761556754264:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv"),
1761556754266:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv"),
1761556754268:times = 10
1761556754272:)
1761556966074:library(data.table)
1761556966651:library(microbenchmark)
1761556967137:library(ggplot2)
1761556967877:# carico le funzioni
1761556967880:source("R/df_functions.R")
1761556968298:source("R/dt_functions.R")
1761556973425:# Task 6
1761556973430:bench6 <- microbenchmark(
1761556973431:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556973434:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761556973436:times = 10
1761556973438:)
1761556976698:autoplot(bench6)
1761556981274:# Task 7
1761556981277:bench7 <- microbenchmark(
1761556981278:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv"),
1761556981281:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv","chr2",2000000,4000000),
1761556981284:times = 10
1761556981286:)
1761556994801:autoplot(bench7)
1761557196026:library(data.table)
1761557196330:library(microbenchmark)
1761557196669:library(ggplot2)
1761557197143:# carico le funzioni
1761557197145:source("R/df_functions.R")
1761557197452:source("R/dt_functions.R")
1761557201801:# Task 7
1761557201802:bench7 <- microbenchmark(
1761557201803:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761557201804:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761557201805:times = 10
1761557201806:)
1761557204273:autoplot(bench7)
1761557209391:# Task 8
1761557209392:bench8 <- microbenchmark(
1761557209394:df_version = gene_stats_filter_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761557209395:dt_version = gene_stats_filter_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761557209396:times = 10
1761557209397:)
1761557222821:autoplot(bench8)
1761557228743:# Task 9
1761557228745:bench9 <- microbenchmark(
1761557228747:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761557228749:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761557228751:times = 10
1761557228753:)
1761559070464:integration_dt <- read.csv("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")
1761559071025:clustering_dt  <- read.csv("project_oct25/nt_combined_clustering.output.csv")
1761559071896:normalize_cell_id <- function(x) {
1761559071899:x <- trimws(as.character(x))
1761559071901:x <- gsub("_X_|_Y_", "_", x)
1761559071902:x <- gsub("_\\.", ".", x)
1761559071904:x
1761559071907:}
1761559072725:integration_dt$cell_clean <- normalize_cell_id(integration_dt$cell)
1761559073407:clustering_dt$cell_clean  <- normalize_cell_id(clustering_dt$cell)
1761559074415:combined <- merge(integration_dt, clustering_dt, by = "cell_clean")
1761559075202:counts_cluster_celltype <- aggregate(cell_clean ~ integration_cluster + cell_type,
1761559075207:data = combined, FUN = length)
1761559075968:names(counts_cluster_celltype)[3] <- "cell_count"
1761559076772:tab_ct_st <- aggregate(cell_clean ~ integration_cluster + cell_type + sample_type,
1761559076776:data = combined, FUN = length)
1761559077564:names(tab_ct_st)[4] <- "cell_count"
1761559078415:totals_cluster <- aggregate(cell_clean ~ integration_cluster, data = combined, FUN = length)
1761559079201:names(totals_cluster)[2] <- "cluster_total_cells"
1761559080059:tab_ct_st <- merge(tab_ct_st, totals_cluster, by = "integration_cluster")
1761559080787:tab_ct_st$pct_within_cluster <- (tab_ct_st$cell_count / tab_ct_st$cluster_total_cells) * 100
1761559081542:totals_cluster_celltype <- aggregate(cell_clean ~ integration_cluster + cell_type,
1761559081545:data = combined, FUN = length)
1761559082240:names(totals_cluster_celltype)[3] <- "cluster_celltype_total"
1761559083052:tab_ct_st <- merge(tab_ct_st, totals_cluster_celltype,
1761559083057:by = c("integration_cluster", "cell_type"))
1761559083853:tab_ct_st$pct_within_cluster_celltype <- (tab_ct_st$cell_count /
1761559083856:tab_ct_st$cluster_celltype_total) * 100
1761559097579:#Per ogni richiesta creerÃ² il codice R semplice (usando data.table e ggplot2 per il plot)
1761559097582:#SETUP PACCHETTI E PERCORSI
1761559097584:# Setup iniziale
1761559097585:library(data.table)   # lavoro tabellare semplice e veloce
1761559098130:library(ggplot2)      # per il plot richiesto
1761559098735:#TASK 1.1
1761559098739:#provide a new file where cell type, cells and integration clusters are combined
1761559098740:#Leggi i due file
1761559098741:integration_dt   <- fread("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")   # colonne attese: cell, integration_cluster
1761559099504:clustering_dt <- fread("project_oct25/nt_combined_clustering.output.csv") # colonne attese: cell, cell_type, sample_type
1761559099962:#Controlliamo i nomi delle colonne #NON RICHIESTO
1761559099966:cat("Colonne in file integrazione:", names(integration_dt), "\n")
1761559100355:cat("Colonne in file clustering: ", names(clustering_dt), "\n")
1761559100775:#Nuova versione di normalizzazione perchÃ¨ i nomi sono diversi: rimuove anche _X_ o _Y_ in mezzo agli ID
1761559100781:normalize_cell_id <- function(x) {
1761559100832:x <- as.character(x)
1761559100872:x <- trimws(x)                     # toglie spazi iniziali/finali
1761559100877:x <- gsub("_X_", "_", x)           # rimuove sequenze _X_ nel mezzo
1761559100880:x <- gsub("_Y_", "_", x)           # rimuove sequenze _Y_ nel mezzo
1761559100882:x <- gsub("_\\.", ".", x)          # rimuove underscore prima del punto
1761559100887:return(x)
1761559100889:}
1761559101102:# Applichiamo la funzione di normalizzazione
1761559101113:integration_dt[, cell_clean := normalize_cell_id(cell)]
1761559101541:clustering_dt[, cell_clean := normalize_cell_id(cell)]
1761559102055:#Unione (join) sui cell id ma i CELL ID NON SONO SCRITTI NELLO STESSO FORMATO NEI DUE FILE
1761559102058:combined <- merge(integration_dt, clustering_dt, by = "cell_clean", all=FALSE) #all FALSE evita duplicazioni indesiderate
1761559102590:#TASK 2.1: provide a file where the number of each cell type is indicated for each cluster
1761559102592:#Per ogni integration_cluster contare quante cells di ciascun cell_type ci sono
1761559102594:#(tabella cluster Ã— cell_type con conti).
1761559102597:# 1. Assicuriamoci di usare la tabella combinata
1761559102598:start_point <- copy(combined)
1761559103334:# 2. Conta per cluster x cell_type
1761559103337:counts_cluster_celltype <- start_point[, .N, by = .(integration_cluster, cell_type)]
1761559104087:setnames(counts_cluster_celltype, "N", "cell_count")
1761559104683:# 1. Ripartiamo da combined
1761559104686:start_point <- copy(combined)
1761559105321:# 2. Conta righe per (cluster, cell_type, sample_type)
1761559105323:tab_ct_st <- start_point[, .N, by = .(integration_cluster, cell_type, sample_type)]
1761559105964:setnames(tab_ct_st, "N", "cell_count")
1761559106544:# 3. Calcola totale per cluster (per normalizzare dentro il cluster)
1761559106546:totals_cluster <- start_point[, .N, by = integration_cluster]
1761559107088:setnames(totals_cluster, "N", "cluster_total_cells")
1761559107565:# 4. Unisci il totale per cluster
1761559107568:tab_ct_st <- merge(tab_ct_st, totals_cluster, by = "integration_cluster", all.x = TRUE)
1761559108079:# 5. Calcolo percentuale dentro cluster (di tutte le celle del cluster)
1761559108083:tab_ct_st[, pct_within_cluster := (cell_count / cluster_total_cells) * 100]
1761559108624:# 6. Calcolo percentuale dentro la coppia (cluster, cell_type) split by sample_type
1761559108627:#    Prima calcolo il totale per (cluster, cell_type) (sommando tutte le sample_type)
1761559108629:totals_cluster_celltype <- start_point[, .N, by = .(integration_cluster, cell_type)]
1761559109142:setnames(totals_cluster_celltype, "N", "cluster_celltype_total")
1761559109627:# 7. Unisco e calcolo la % di sample_type all'interno del (cluster, cell_type)
1761559109629:tab_ct_st <- merge(tab_ct_st, totals_cluster_celltype, by = c("integration_cluster", "cell_type"), all.x = TRUE)
1761559110121:tab_ct_st[, pct_within_cluster_celltype := (cell_count / cluster_celltype_total) * 100]
1761559110603:# 8. Riordino colonne per chiarezza e salvo
1761559110607:setcolorder(tab_ct_st, c("integration_cluster", "cell_type", "sample_type",
1761559110608:"cell_count", "cluster_celltype_total", "pct_within_cluster_celltype",
1761559110610:"cluster_total_cells", "pct_within_cluster"))
1761559111201:out3 <- paste0("_summary_cluster_celltype_sampletype.csv")
1761559111662:fwrite(tab_ct_st, out3)
1761559112422:# Usiamo il file che hai giÃ  creato nel Task 1
1761559112425:# (quello con le colonne: cell_type, integration_cluster, sample_type)
1761559112427:data <- combined
1761559113051:# Contiamo quante celle ci sono per combinazione di cluster, tipo di cellula e tipo di tessuto
1761559113054:counts <- as.data.frame(table(data$integration_cluster, data$cell_type, data$sample_type))
1761559113724:names(counts) <- c("cluster", "cell_type", "tissue", "count")
1761559114392:# Calcoliamo la percentuale di ogni cell_type dentro ciascun cluster e tessuto
1761559114397:# Per farlo, prima troviamo il totale per cluster e tessuto
1761559114399:totals <- aggregate(count ~ cluster + tissue, data = counts, sum)
1761559114902:names(totals)[3] <- "total" #cambia il nome della terza colonna da counts a total
1761559115380:# Ora uniamo le due tabelle
1761559115383:counts2 <- merge(counts, totals, by = c("cluster", "tissue"))
1761559115876:# Calcoliamo la percentuale
1761559115879:counts2$percent <- (counts2$count / counts2$total) * 100
1761559116421:# Facciamo il grafico
1761559116424:ggplot(counts2, aes(x = cluster, y = percent, fill = cell_type)) +
1761559116426:geom_bar(stat = "identity") +
1761559116427:facet_wrap(~ tissue) +
1761559116428:labs(title = "Distribution of cell types in clusters",
1761559116429:x = "Integration cluster",
1761559116431:y = "Cells percentage (%)") +
1761559116432:theme_minimal() +
1761559116434:theme(axis.text.x = element_text(angle = 45, hjust = 1))
1761559118017:library(data.table)
1761559118018:# Assumiamo di partire da 'combined' (giÃ  creato nei task precedenti)
1761559118018:data_dt <- as.data.table(combined)
1761559120333:# Conta quante celle per cluster, tipo cellulare e tessuto
1761559120336:counts <- data_dt[, .N, by = .(cluster = integration_cluster,
1761559120338:cell_type,
1761559120341:tissue = sample_type)]
1761559120353:# Calcola il totale per ogni cluster e tipo di tessuto
1761559120354:totals <- counts[, .(total = sum(N)), by = .(cluster, tissue)]
1761559120362:# Unisci i totali ai conteggi
1761559120363:counts <- merge(counts, totals, by = c("cluster", "tissue"))
1761559120374:# Calcola la percentuale normalizzata
1761559120375:counts[, percent := round((N / total) * 100, 2)]
1761559120786:# Riordina per cluster e (opzionale) per tissue
1761559120788:setorder(counts, cluster, tissue)
1761559493877:#=========================================
1761559493879:# SETUP PACCHETTI E PERCORSI
1761559493881:#=========================================
1761559493881:library(ggplot2)
1761559494440:library(dplyr)
1761559507553:#=========================================
1761559507555:# SETUP PACCHETTI E PERCORSI
1761559507559:#=========================================
1761559507561:library(ggplot2)
1761559508086:library(dplyr)
1761559509232:#=========================================
1761559509234:# LETTURA FILE DI INPUT
1761559509235:#=========================================
1761559509236:integration_dt <- read.csv("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")
1761559510200:clustering_dt  <- read.csv("project_oct25/nt_combined_clustering.output.csv")
1761559511227:#=========================================
1761559511232:# FUNZIONE PER NORMALIZZARE GLI ID CELLULARI
1761559511235:#=========================================
1761559511237:normalize_cell_id <- function(x) {
1761559511242:x <- as.character(x)
1761559511247:x <- trimws(x)
1761559511250:x <- gsub("_X_", "_", x)
1761559511253:x <- gsub("_Y_", "_", x)
1761559511254:x <- gsub("_\\.", ".", x)
1761559511257:return(x)
1761559511259:}
1761559512569:#TASK 1
1761559512572:integration_dt$cell_clean <- normalize_cell_id(integration_dt$cell)
1761559513108:clustering_dt$cell_clean  <- normalize_cell_id(clustering_dt$cell)
1761559514220:combined <- merge(integration_dt, clustering_dt, by = "cell_clean")
1761559533978:write.csv(combined,
1761559533981:"project_oct25/combined_integration_clustering.csv",
1761559533984:row.names = FALSE)
1761559535334:#TASK 2
1761559535336:counts_cluster_celltype <- combined %>%
1761559535338:group_by(integration_cluster, cell_type) %>%
1761559535340:summarise(cell_count = n())
1761559536259:write.csv(counts_cluster_celltype,
1761559536270:"project_oct25/celltype_counts_per_cluster.csv",
1761559536277:row.names = FALSE)
1761559541038:#TASK 3
1761559541043:# Counts by cluster + cell type + tissue
1761559541044:tab_ct_st <- combined %>%
1761559541046:group_by(integration_cluster, cell_type, sample_type) %>%
1761559541047:summarise(cell_count = n())
1761559542508:# Total cells per cluster
1761559542511:totals_cluster <- combined %>%
1761559542513:group_by(integration_cluster) %>%
1761559542514:summarise(cluster_total_cells = n())
1761559543789:tab_ct_st <- merge(tab_ct_st, totals_cluster, by = "integration_cluster")
1761559544648:tab_ct_st$pct_within_cluster <- (tab_ct_st$cell_count / tab_ct_st$cluster_total_cells) * 100
1761559545512:# Total per (cluster, cell_type)
1761559545515:totals_cluster_celltype <- combined %>%
1761559545516:group_by(integration_cluster, cell_type) %>%
1761559545518:summarise(cluster_celltype_total = n())
1761559549814:tab_ct_st <- merge(tab_ct_st,
1761559549816:totals_cluster_celltype,
1761559549818:by = c("integration_cluster", "cell_type"))
1761559551130:tab_ct_st$pct_within_cluster_celltype <- (tab_ct_st$cell_count / tab_ct_st$cluster_celltype_total) * 100
1761559565206:write.csv(tab_ct_st,
1761559565210:"project_oct25/summary_cluster_celltype_tissue.csv",
1761559565213:row.names = FALSE)
1761559566972:#TASK 4
1761559566975:counts <- as.data.frame(table(combined$integration_cluster,
1761559566977:combined$cell_type,
1761559566978:combined$sample_type))
1761559568265:names(counts) <- c("cluster", "cell_type", "tissue", "count")
1761559569077:totals <- aggregate(count ~ cluster + tissue, data = counts, sum)
1761559569601:names(totals)[3] <- "total_cluster_tissue"
1761559570295:counts2 <- merge(counts, totals, by = c("cluster", "tissue"))
1761559570876:counts2$percent <- (counts2$count / counts2$total_cluster_tissue) * 100
1761559572296:ggplot(counts2, aes(x = cluster, y = percent, fill = cell_type)) +
1761559572301:geom_bar(stat = "identity") +
1761559572302:facet_wrap(~ tissue) +
1761559572304:labs(title = "Distribution of Cell Types in Normal/Tumor Tissue",
1761559572307:x = "Integration Cluster",
1761559572309:y = "Percentage of Cells (%)") +
1761559572311:theme_minimal() +
1761559572312:theme(axis.text.x = element_text(angle = 45, hjust = 1))
1761559598382:#TASK 5
1761559598384:counts_normalized <- combined %>%
1761559598385:group_by(cluster = integration_cluster, cell_type, tissue = sample_type) %>%
1761559598387:summarise(N = n())
1761559598518:totals <- counts_normalized %>%
1761559598519:group_by(cluster, tissue) %>%
1761559598520:summarise(total = sum(N))
1761559598612:counts_normalized <- merge(counts_normalized, totals, by = c("cluster", "tissue"))
1761559598617:counts_normalized <- counts_normalized[order(counts_normalized$cluster, counts_normalized$tissue), ]
1761559598662:counts_normalized$percent <- round((counts_normalized$N / counts_normalized$total) * 100, 2)
1761559599834:write.csv(counts_normalized,
1761559599836:"project_oct25/normalized_celltype_percentages_by_tissue.csv",
1761559599837:row.names = FALSE)
1761559777540:#TASK 1.1
1761559777543:#provide a new file where cell type, cells and integration clusters are combined
1761559777548:#Leggi i due file
1761559777551:integration_dt   <- fread("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")   # colonne attese: cell, integration_cluster
1761559778257:clustering_dt <- fread("project_oct25/nt_combined_clustering.output.csv") # colonne attese: cell, cell_type, sample_type
1761559779484:View(clustering_dt)
1761559780610:View(integration_dt)
1761561070912:library(data.table)
1761561071353:library(microbenchmark)
1761561071844:library(ggplot2)
1761561074063:# carico le funzioni
1761561074065:source("R/df_functions.R")
1761561074886:source("R/dt_functions.R")
1761561081591:#FINAL REVISION
1761561081595:# Task 1.1
1761561081598:bench1.1 <- microbenchmark(
1761561081600:df_version = combine_integration_clustering_df("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761561081603:dt_version = combine_integration_clustering_dt ("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761561081608:times = 10
1761561081612:)
1761561154067:#FINAL REVISION
1761561154071:# Task 1.1
1761561154072:bench1.1 <- microbenchmark(
1761561154074:df_version = combine_integration_clustering_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761561154076:dt_version = combine_integration_clustering_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761561154078:times = 10
1761561154079:)
1761561161419:autoplot(bench1.1)
1761562580799:# ==========================================
1761562580803:# SETUP
1761562580805:# ==========================================
1761562580806:library(data.table)
1761562581329:library(ggplot2)
1761562590330:# ==========================================
1761562590339:# LETTURA FILE DI INPUT
1761562590341:# ==========================================
1761562590343:integration_dt <- fread("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")
1761562592670:# ==========================================
1761562592676:# SETUP
1761562592683:# ==========================================
1761562592688:library(data.table)
1761562593595:library(ggplot2)
1761562597271:# ==========================================
1761562597275:# LETTURA FILE DI INPUT
1761562597277:# ==========================================
1761562597279:integration_dt <- fread("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")
1761562598356:clustering_dt  <- fread("project_oct25/nt_combined_clustering.output.csv")
1761562601755:# ==========================================
1761562601760:# FUNZIONE NORMALIZZAZIONE ID CELLULARI (necessaria)
1761562601763:# ==========================================
1761562601777:normalize_cell_id <- function(x) {
1761562601780:x <- as.character(x)
1761562601782:x <- trimws(x)
1761562601791:x <- gsub("_X_", "_", x)
1761562601796:x <- gsub("_Y_", "_", x)
1761562601798:x <- gsub("_\\.", ".", x)
1761562601801:return(x)
1761562601802:}
1761562603497:integration_dt[, cell_clean := normalize_cell_id(cell)]
1761562604203:clustering_dt[, cell_clean := normalize_cell_id(cell)]
1761562607598:combined <- merge(integration_dt, clustering_dt, by = "cell_clean", all = FALSE)
1761562718522:# ==========================================
1761562718525:# SETUP
1761562718527:# ==========================================
1761562718528:library(data.table)
1761562719511:library(ggplot2)
1761562720660:# ==========================================
1761562720662:# LETTURA FILE DI INPUT
1761562720663:# ==========================================
1761562720664:integration_dt <- fread("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")
1761562720820:clustering_dt  <- fread("project_oct25/nt_combined_clustering.output.csv")
1761562721724:# ==========================================
1761562721732:# FUNZIONE NORMALIZZAZIONE ID CELLULARI (necessaria)
1761562721736:# ==========================================
1761562721740:normalize_cell_id <- function(x) {
1761562721742:x <- as.character(x)
1761562721744:x <- trimws(x)
1761562721745:x <- gsub("_X_", "_", x)
1761562721747:x <- gsub("_Y_", "_", x)
1761562721752:x <- gsub("_\\.", ".", x)
1761562721754:return(x)
1761562721757:}
1761562722479:integration_dt[, cell_clean := normalize_cell_id(cell)]
1761562722994:clustering_dt[, cell_clean := normalize_cell_id(cell)]
1761562723899:combined <- merge(integration_dt, clustering_dt, by = "cell_clean", all = FALSE)
1761562725320:fwrite(combined,
1761562725323:file = "Outputs/combined_celltype_integrationcluster.csv")
1761562732086:counts_cluster_celltype <- combined[, .N, by = .(integration_cluster, cell_type)]
1761562733084:setnames(counts_cluster_celltype, "N", "cell_count")
1761562733695:fwrite(counts_cluster_celltype,
1761562733700:file = "Outputs/celltype_counts_per_cluster.csv")
1761562734961:# Conta celle per cluster Ã— cell_type Ã— sample_type
1761562734965:tab_ct_st <- combined[, .N, by = .(integration_cluster, cell_type, sample_type)]
1761562735598:setnames(tab_ct_st, "N", "cell_count")
1761562736285:# Totale celle per cluster
1761562736290:totals_cluster <- combined[, .N, by = integration_cluster]
1761562736900:setnames(totals_cluster, "N", "cluster_total_cells")
1761562737444:tab_ct_st <- merge(tab_ct_st, totals_cluster, by = "integration_cluster")
1761562737925:# Percentuale all'interno del cluster
1761562737929:tab_ct_st[, pct_within_cluster := (cell_count / cluster_total_cells) * 100]
1761562738455:# Totale celle per cluster Ã— cell_type
1761562738458:totals_cluster_celltype <- combined[, .N, by = .(integration_cluster, cell_type)]
1761562738949:setnames(totals_cluster_celltype, "N", "cluster_celltype_total")
1761562739438:tab_ct_st <- merge(tab_ct_st, totals_cluster_celltype,
1761562739440:by = c("integration_cluster", "cell_type"))
1761562740062:# Percentuale di sample_type all'interno di quel tipo cellulare nel cluster
1761562740081:tab_ct_st[, pct_within_cluster_celltype := (cell_count / cluster_celltype_total) * 100]
1761562740495:fwrite(tab_ct_st,
1761562740498:file = "Outputs/summary_cluster_celltype_tissue.csv")
1761562741630:plot_data <- as.data.frame(table(combined$integration_cluster,
1761562741635:combined$cell_type,
1761562741636:combined$sample_type))
1761562742388:names(plot_data) <- c("cluster", "cell_type", "tissue", "count")
1761562743203:totals <- aggregate(count ~ cluster + tissue, data = plot_data, sum)
1761562744249:names(totals)[3] <- "total"
1761562744848:plot_data <- merge(plot_data, totals, by = c("cluster", "tissue"))
1761562745390:plot_data$percent <- (plot_data$count / plot_data$total) * 100
1761562745926:ggplot(plot_data, aes(x = cluster, y = percent, fill = cell_type)) +
1761562745936:geom_bar(stat = "identity") +
1761562745941:facet_wrap(~ tissue) +
1761562745943:labs(title = "Distribution of cell types in clusters",
1761562745945:x = "Integration cluster",
1761562745947:y = "Cells percentage (%)") +
1761562745951:theme_minimal() +
1761562745961:theme(axis.text.x = element_text(angle = 45, hjust = 1))
1761562775119:# ==========================================
1761562775121:# TASK 5.1
1761562775123:# ==========================================
1761562775125:counts_norm <- combined[, .N, by = .(cluster = integration_cluster,
1761562775127:cell_type,
1761562775129:tissue = sample_type)]
1761562775144:totals_norm <- counts_norm[, .(total = sum(N)), by = .(cluster, tissue)]
1761562775156:counts_norm <- merge(counts_norm, totals_norm, by = c("cluster", "tissue"))
1761562775169:counts_norm[, percent := round((N / total) * 100, 2)]
1761562775470:fwrite(counts_norm,
1761562775473:file = "Outputs/normalized_celltype_percentages_by_tissue.csv")
1761563338176:# Carichiamo solo i pacchetti necessari
1761563338179:library(ggplot2)
1761563339230:# Funzione di normalizzazione ID cellule
1761563339234:normalize_cell_id <- function(x) {
1761563339236:x <- as.character(x)
1761563339237:x <- trimws(x)
1761563339238:x <- gsub("_X_", "_", x)
1761563339241:x <- gsub("_Y_", "_", x)
1761563339243:x <- gsub("_\\.", ".", x)
1761563339246:return(x)
1761563339249:}
1761563340011:# Leggi i file in data.frame
1761563340015:integration_df <- read.csv("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")
1761563340857:clustering_df  <- read.csv("project_oct25/nt_combined_clustering.output.csv")
1761563341484:# Normalizza gli ID
1761563341487:integration_df$cell_clean <- normalize_cell_id(integration_df$cell)
1761563342009:clustering_df$cell_clean  <- normalize_cell_id(clustering_df$cell)
1761563342445:# Join sulle cellule
1761563342449:combined_df <- merge(integration_df, clustering_df, by = "cell_clean", all = FALSE)
1761563342872:# Salva file Task 1
1761563342876:write.csv(combined_df, "combined_cell_cluster_celltype.csv", row.names = FALSE)
1761563343342:counts_cluster_celltype <- aggregate(cell_clean ~ integration_cluster + cell_type,
1761563343345:data = combined_df, FUN = length)
1761563343814:colnames(counts_cluster_celltype)[3] <- "cell_count"
1761563438133:# Carichiamo solo i pacchetti necessari
1761563438135:library(ggplot2)
1761563438512:# Funzione di normalizzazione ID cellule
1761563438514:normalize_cell_id <- function(x) {
1761563438517:x <- as.character(x)
1761563438519:x <- trimws(x)
1761563438522:x <- gsub("_X_", "_", x)
1761563438525:x <- gsub("_Y_", "_", x)
1761563438528:x <- gsub("_\\.", ".", x)
1761563438533:return(x)
1761563438535:}
1761563438935:# Leggi i file in data.frame
1761563438937:integration_df <- read.csv("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv")
1761563439359:clustering_df  <- read.csv("project_oct25/nt_combined_clustering.output.csv")
1761563439737:# Normalizza gli ID
1761563439740:integration_df$cell_clean <- normalize_cell_id(integration_df$cell)
1761563440105:clustering_df$cell_clean  <- normalize_cell_id(clustering_df$cell)
1761563440577:# Join sulle cellule
1761563440580:combined_df <- merge(integration_df, clustering_df, by = "cell_clean", all = FALSE)
1761563441073:# Salva file Task 1
1761563441077:write.csv(combined_df, "Outputs/combined_cell_cluster_celltype.csv", row.names = FALSE)
1761563441497:counts_cluster_celltype <- aggregate(cell_clean ~ integration_cluster + cell_type,
1761563441501:data = combined_df, FUN = length)
1761563441912:colnames(counts_cluster_celltype)[3] <- "cell_count"
1761563442287:write.csv(counts_cluster_celltype, "Outputs/counts_per_cluster_celltype.csv", row.names = FALSE)
1761563442864:# Conta per cluster, cell_type, sample_type
1761563442868:tab_ct_st <- aggregate(cell_clean ~ integration_cluster + cell_type + sample_type,
1761563442871:data = combined_df, FUN = length)
1761563443337:colnames(tab_ct_st)[4] <- "cell_count"
1761563443799:# Totale per cluster
1761563443802:totals_cluster <- aggregate(cell_clean ~ integration_cluster,
1761563443804:data = combined_df, FUN = length)
1761563444208:colnames(totals_cluster)[2] <- "cluster_total_cells"
1761563444634:# Merge per aggiungere totale cluster
1761563444637:tab_ct_st <- merge(tab_ct_st, totals_cluster, by = "integration_cluster", all.x = TRUE)
1761563445111:# Percentuale dentro cluster
1761563445114:tab_ct_st$pct_within_cluster <- (tab_ct_st$cell_count / tab_ct_st$cluster_total_cells) * 100
1761563445590:# Totale per (cluster, cell_type)
1761563445592:totals_cluster_celltype <- aggregate(cell_clean ~ integration_cluster + cell_type,
1761563445594:data = combined_df, FUN = length)
1761563446069:colnames(totals_cluster_celltype)[3] <- "cluster_celltype_total"
1761563446583:# Merge + percentuale sample_type dentro cell_type del cluster
1761563446586:tab_ct_st <- merge(tab_ct_st, totals_cluster_celltype,
1761563446589:by = c("integration_cluster", "cell_type"), all.x = TRUE)
1761563447310:tab_ct_st$pct_within_cluster_celltype <- (tab_ct_st$cell_count / tab_ct_st$cluster_celltype_total) * 100
1761563448104:# Salva Task 3
1761563448108:write.csv(tab_ct_st, "Outputs/summary_cluster_celltype_sampletype.csv", row.names = FALSE)
1761563449250:plot_data <- as.data.frame(table(combined_df$integration_cluster,
1761563449254:combined_df$cell_type,
1761563449256:combined_df$sample_type))
1761563450339:colnames(plot_data) <- c("cluster", "cell_type", "tissue", "count")
1761563450851:# Totale per cluster e tessuto
1761563450853:totals <- aggregate(count ~ cluster + tissue, data = plot_data, sum)
1761563451610:colnames(totals)[3] <- "total"
1761563452336:# Merge + percentuali
1761563452340:plot_data <- merge(plot_data, totals, by = c("cluster", "tissue"))
1761563452797:plot_data$percent <- (plot_data$count / plot_data$total) * 100
1761563453347:# Plot
1761563453351:ggplot(plot_data, aes(x = cluster, y = percent, fill = cell_type)) +
1761563453354:geom_bar(stat = "identity") +
1761563453355:facet_wrap(~ tissue) +
1761563453356:labs(title = "Distribution of cell types in clusters (Normal vs Tumor)",
1761563453358:x = "Integration Cluster",
1761563453359:y = "Cell Percentage (%)") +
1761563453361:theme_minimal()
1761563457972:# ==========================================
1761563457976:# TASK 5.1
1761563457978:# ==========================================
1761563457980:# Conta celle
1761563457981:counts <- as.data.frame(table(combined_df$integration_cluster,
1761563457982:combined_df$cell_type,
1761563457984:combined_df$sample_type))
1761563458886:colnames(counts) = c("cluster", "cell_type", "tissue", "count")
1761563459394:# Totale per cluster e tessuto
1761563459397:totals <- aggregate(count ~ cluster + tissue, data = counts, sum)
1761563459822:colnames(totals)[3] <- "total"
1761563460294:# Merge e calcolo % normalizzata
1761563460295:counts_norm <- merge(counts, totals, by = c("cluster", "tissue"))
1761563460748:counts_norm$percent <- round((counts_norm$count / counts_norm$total) * 100, 2)
1761563461248:# Salva Task 5
1761563461251:write.csv(counts_norm, "Outputs/normalized_percent_cluster_celltype_tissue.csv", row.names = FALSE)
1761563478431:library(data.table)
1761563478773:library(microbenchmark)
1761563479114:library(ggplot2)
1761563480797:# carico le funzioni
1761563480800:source("R/df_functions.R")
1761563481096:source("R/dt_functions.R")
1761563491544:#FINAL REVISION
1761563491549:benchfr <- microbenchmark(
1761563491554:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761563491557:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761563491559:times = 10
1761563491560:)
1761563513597:# carico le funzioni
1761563513604:source("R/df_functions.R")
1761563514012:source("R/dt_functions.R")
1761563517541:#FINAL REVISION
1761563517547:benchfr <- microbenchmark(
1761563517552:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761563517556:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761563517558:times = 10
1761563517561:)
1761563521314:autoplot(benchfr)
1761564380617:library(data.table)
1761564380888:library(microbenchmark)
1761564381146:library(ggplot2)
1761564382980:# carico le funzioni
1761564382982:source("R/df_functions.R")
1761564383284:source("R/dt_functions.R")
1761564386301:#FINAL REVISION
1761564386304:benchfr <- microbenchmark(
1761564386305:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761564386306:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761564386307:times = 10
1761564386308:)
1761564538247:benchfr
1761564898633:library(data.table)
1761564898781:library(microbenchmark)
1761564898940:library(ggplot2)
1761564899103:# carico le funzioni
1761564899109:source("R/df_functions.R")
1761564899248:source("R/dt_functions.R")
1761564899427:# Task 1
1761564899435:bench1 <- microbenchmark(
1761564899437:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761564899438:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761564899440:times = 10
1761564899440:)
1761564901839:autoplot(bench1)
1761564902181:# Task 2
1761564902182:bench2 <- microbenchmark(
1761564902183:df_version = bulk_counts_qc_df("project_oct25/bulk_counts_long.csv"),
1761564902184:dt_version = bulk_counts_qc_dt("project_oct25/bulk_counts_long.csv"),
1761564902185:times = 10
1761564902186:)
1761564903671:autoplot(bench2)
1761564904012:# Task 4
1761564904013:bench4 <- microbenchmark(
1761564904014:df_version = annotate_counts_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761564904015:dt_version = annotate_counts_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761564904016:times = 10
1761564904016:)
1761564905412:autoplot(bench4)
1761564905665:# Task 5
1761564905666:bench5 <- microbenchmark(
1761564905668:df_version = classify_labs_df("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761564905669:dt_version = classify_labs_dt("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761564905670:times = 10
1761564905671:)
1761564906273:autoplot(bench5)
1761564906527:# Task 6
1761564906528:bench6 <- microbenchmark(
1761564906528:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761564906529:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761564906530:times = 10
1761564906530:)
1761564909904:autoplot(bench6)
1761564910132:# Task 7
1761564910133:bench7 <- microbenchmark(
1761564910134:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761564910134:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761564910135:times = 10
1761564910135:)
1761564910979:autoplot(bench7)
1761564911307:# Task 8
1761564911308:bench8 <- microbenchmark(
1761564911309:df_version = gene_stats_filter_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761564911310:dt_version = gene_stats_filter_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761564911311:times = 10
1761564911311:)
1761564922296:autoplot(bench8)
1761564922540:# Task 9
1761564922540:bench9 <- microbenchmark(
1761564922541:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761564922541:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761564922542:times = 10
1761564922542:)
1761564924350:autoplot(bench9)
1761564924590:# Task 10
1761564924590:bench10 <- microbenchmark(
1761564924591:df_version = atac_to_gene_df("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761564924591:dt_version = atac_to_gene_dt("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761564924592:times = 10
1761564924592:)
1761564941398:autoplot(bench10)
1761564941664:# Task 11
1761564941664:bench11 <- microbenchmark(
1761564941665:df_version = variants_to_genes_df("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761564941666:dt_version = variants_to_genes_dt("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761564941666:times = 10
1761564941667:)
1761564948648:autoplot(bench11)
1761564948874:# Task 12
1761564948875:bench12 <- microbenchmark(
1761564948876:df_version = combine_cohorts_df("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761564948876:dt_version = combine_cohorts_dt("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761564948877:times = 10
1761564948877:)
1761564950208:autoplot(bench12)
1761564950460:#FINAL REVISION
1761564950460:benchfr <- microbenchmark(
1761564950461:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761564950462:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761564950462:times = 10
1761564950463:)
1761564954143:autoplot(benchfr)
1761564954428:results <- rbindlist(list(
1761564954428:task1 = as.data.table(bench1),
1761564954429:task2 = as.data.table(bench2),
1761564954429:task4 = as.data.table(bench4),
1761564954430:task5 = as.data.table(bench5),
1761564954430:task6 = as.data.table(bench6),
1761564954431:task7 = as.data.table(bench7),
1761564954431:task8 = as.data.table(bench8),
1761564954432:task9 = as.data.table(bench9),
1761564954432:task10 = as.data.table(bench10),
1761564954433:task11 = as.data.table(bench11),
1761564954433:task12 = as.data.table(bench12),
1761564954434:final_revision = as.data.table(benchfr)
1761564954435:), idcol = "task")[, dcast(.SD[, .(task, expr, mean)], task ~ expr, value.var = "mean")]
1761564954445:setnames(results, c("task","df_version","dt_version"), c("task","df_mean","dt_mean"))
1761564954445:results
1761564962809:View(results)
1761564981383:View(bench1)
1761564992089:View(bench1)
1761565049122:View(bench1)
1761565110855:View(bench1)
1761565117432:bench1
1761565173192:results <- rbindlist(list(
1761565173196:task1 = as.data.table(bench1),
1761565173198:task2 = as.data.table(bench2),
1761565173199:task4 = as.data.table(bench4),
1761565173201:task5 = as.data.table(bench5),
1761565173202:task6 = as.data.table(bench6),
1761565173203:task7 = as.data.table(bench7),
1761565173204:task8 = as.data.table(bench8),
1761565173206:task9 = as.data.table(bench9),
1761565173208:task10 = as.data.table(bench10),
1761565173211:task11 = as.data.table(bench11),
1761565173215:task12 = as.data.table(bench12),
1761565173217:final_revision = as.data.table(benchfr)
1761565173219:), idcol = "task")[, .(df_mean = mean(time[expr=="df_version"]),
1761565173221:dt_mean = mean(time[expr=="dt_version"])),
1761565173223:by = task]
1761565176101:results
1761565178875:View(results)
1761565263984:results <- rbindlist(list(
1761565263988:task1 = as.data.table(bench1),
1761565263990:task2 = as.data.table(bench2),
1761565263991:task4 = as.data.table(bench4),
1761565263992:task5 = as.data.table(bench5),
1761565263993:task6 = as.data.table(bench6),
1761565263994:task7 = as.data.table(bench7),
1761565263996:task8 = as.data.table(bench8),
1761565263998:task9 = as.data.table(bench9),
1761565264001:task10 = as.data.table(bench10),
1761565264004:task11 = as.data.table(bench11),
1761565264005:task12 = as.data.table(bench12),
1761565264008:final_revision = as.data.table(benchfr)
1761565264009:), idcol = "task")[, .(df_mean = mean(time[expr=="df_version"])/1e6,
1761565264010:dt_mean = mean(time[expr=="dt_version"])/1e6),
1761565264011:by = task]
1761565268753:View(results)
1761565489082:devtools::document()
1761565515697:devtools::document()
1761565887679:devtools::load_all()
1761565895541:devtools::document()
1761566227753:devtools::document()
1761566309381:devtools::document()
1761566608181:devtools::document()
1761566734148:?usethis
1761566827738:t <- bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv")
1761566832153:View(t)
1761566853442:t <- bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv")
1761566876906:t <- bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv")
1761566885221:library(Project_Alessandra)
1761566899697:devtools::document()
1761566910667:devtools::load_all()
1761566919416:library(Project_Alessandra)
1761566920749:t <- bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv")
1761585029385:devtools::document()
1761585036376:devtools::load_all()
1761585058854:library(data.table)
1761585058980:library(microbenchmark)
1761585059143:library(ggplot2)
1761585059528:# carico le funzioni
1761585059529:source("R/df_functions.R")
1761585059535:source("R/dt_functions.R")
1761585059708:# Task 1
1761585059711:bench1 <- microbenchmark(
1761585059715:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761585059718:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761585059723:times = 10
1761585059724:)
1761585062229:autoplot(bench1)
1761585063012:# Task 2
1761585063014:bench2 <- microbenchmark(
1761585063016:df_version = bulk_counts_qc_df("project_oct25/bulk_counts_long.csv"),
1761585063017:dt_version = bulk_counts_qc_dt("project_oct25/bulk_counts_long.csv"),
1761585063020:times = 10
1761585063022:)
1761585064850:autoplot(bench2)
1761585065102:# Task 4
1761585065103:bench4 <- microbenchmark(
1761585065103:df_version = annotate_counts_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761585065104:dt_version = annotate_counts_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761585065105:times = 10
1761585065106:)
1761585066522:autoplot(bench4)
1761585066822:# Task 5
1761585066823:bench5 <- microbenchmark(
1761585066824:df_version = classify_labs_df("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761585066825:dt_version = classify_labs_dt("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761585066826:times = 10
1761585066827:)
1761585067539:autoplot(bench5)
1761585067815:# Task 6
1761585067816:bench6 <- microbenchmark(
1761585067817:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761585067818:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761585067818:times = 10
1761585067819:)
1761585071219:autoplot(bench6)
1761585071471:# Task 7
1761585071472:bench7 <- microbenchmark(
1761585071472:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761585071473:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761585071474:times = 10
1761585071475:)
1761585072083:autoplot(bench7)
1761585072347:# Task 8
1761585072348:bench8 <- microbenchmark(
1761585072349:df_version = gene_stats_filter_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761585072349:dt_version = gene_stats_filter_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761585072350:times = 10
1761585072350:)
1761585082668:autoplot(bench8)
1761585082933:# Task 9
1761585082934:bench9 <- microbenchmark(
1761585082935:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761585082936:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761585082938:times = 10
1761585082939:)
1761585084887:autoplot(bench9)
1761585085118:# Task 10
1761585085119:bench10 <- microbenchmark(
1761585085120:df_version = atac_to_gene_df("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761585085121:dt_version = atac_to_gene_dt("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761585085121:times = 10
1761585085122:)
1761585103484:autoplot(bench10)
1761585103719:# Task 11
1761585103720:bench11 <- microbenchmark(
1761585103721:df_version = variants_to_genes_df("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761585103722:dt_version = variants_to_genes_dt("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761585103722:times = 10
1761585103723:)
1761585110844:autoplot(bench11)
1761585111245:# Task 12
1761585111246:bench12 <- microbenchmark(
1761585111247:df_version = combine_cohorts_df("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761585111248:dt_version = combine_cohorts_dt("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761585111248:times = 10
1761585111249:)
1761585112631:autoplot(bench12)
1761585112874:#FINAL REVISION
1761585112875:benchfr <- microbenchmark(
1761585112876:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761585112877:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761585112877:times = 10
1761585112878:)
1761585116611:autoplot(benchfr)
1761585116882:results <- rbindlist(list(
1761585116882:task1 = as.data.table(bench1),
1761585116883:task2 = as.data.table(bench2),
1761585116884:task4 = as.data.table(bench4),
1761585116885:task5 = as.data.table(bench5),
1761585116885:task6 = as.data.table(bench6),
1761585116886:task7 = as.data.table(bench7),
1761585116887:task8 = as.data.table(bench8),
1761585116887:task9 = as.data.table(bench9),
1761585116888:task10 = as.data.table(bench10),
1761585116889:task11 = as.data.table(bench11),
1761585116889:task12 = as.data.table(bench12),
1761585116890:final_revision = as.data.table(benchfr)
1761585116891:), idcol = "task")[, .(df_mean = mean(time[expr=="df_version"])/1e6,
1761585116891:dt_mean = mean(time[expr=="dt_version"])/1e6),
1761585116892:by = task]
1761585137705:View(results)
1761585491646:devtools::install()
1761585658180:devtools::document()
1761585675558:devtools::document()
1761585774087:devtools::document()
1761585885291:devtools::document()
1761585897108:devtools::document()
1761585973109:# Mostra il DESCRIPTION con numeri di riga
1761585973111:lines <- readLines("DESCRIPTION", warn = FALSE)
1761585973113:for (i in seq_along(lines)) {
1761585973114:cat(sprintf("%3d: %s\n", i, lines[i]))
1761585973115:}
1761586038412:usethis::use_mit_license("Alessandra Monterosso")
1761586089364:devtools::document()
1761586163105:usethis::use_mit_license("Alessandra Monterosso")
1761586230289:usethis::create_description(
1761586230294:fields = list(
1761586230296:Package = "Project_Alessandra",
1761586230297:Title = "Data manipulation and analysis tools for genomics and bulk RNA-seq",
1761586230298:Version = "0.0.0.9000",
1761586230300:Description = "Tools for data.table and RNA-seq data manipulation.",
1761586230301:`Authors@R` = 'person("Alessandra", "Monterosso", email = "alessandramonte050@gmail.com", role = c("aut", "cre"))',
1761586230302:License = "MIT + file LICENSE",
1761586230304:Encoding = "UTF-8"
1761586230305:)
1761586230307:)
1761586258616:usethis::use_mit_license("Alessandra Monterosso")
1761586329548:devtools::document()
1761586359823:devtools::document()
1761586404219:file.remove("DESCRIPTION")
1761586451173:usethis::use_description(fields = list(
1761586451176:Package = "Project_Alessandra",
1761586451177:Title = "Data manipulation and analysis tools for genomics and bulk RNA-seq",
1761586451178:`Authors@R` = 'person("Alessandra", "Monterosso", email = "alessandramonte050@gmail.com", role = c("aut", "cre"))',
1761586451179:Description = "This package provides tools to manipulate, summarize, and analyze genomics datasets.",
1761586451180:License = "MIT + file LICENSE",
1761586451181:Encoding = "UTF-8"
1761586451182:))
1761586539302:devtools::document()
1761586579849:devtools::document()
1761586613618:devtools::document()
1761586622910:devtools::build()
1761586643019:.Last.error
1761586724793:devtools::document()
1761586734030:devtools::build()
1761586817011:# Imposta la cartella del progetto come destinazione del build
1761586817013:pkg_path <- getwd()  # cartella corrente del progetto
1761586817016:# Build del pacchetto in una cartella scrivibile
1761586817016:devtools::build(path = pkg_path)
1761586820915:# Installazione diretta del pacchetto
1761586820917:devtools::install(pkg = pkg_path)
1761586873951:# Se vuoi usare la versione nuova
1761586873954:detach("package:Project_Alessandra", unload = TRUE)
1761586873961:library(ProjectAlessandra)
1761586881806:detach("package:Project_Alessandra", unload = TRUE)
1761586951508:search()
1761586998407:library(ProjectAlessandra)
1761587008813:ls("package:ProjectAlessandra")
1761587348183:devtools::documeny()
1761587356464:devtools::document()
1761587368163:devtools::loadl_all()
1761587377438:devtools::load_all()
1761587417392:devtools::install()
1761587476687:library(ProjectAlessandra)
1761587486067:ls("package:ProjectAlessandra")
1761587573853:?count_cells_per_cluster_dt
1761587619519:?classify_labs_df
1761587671107:?final_revision_dt
1761588169987:usethis::use_vignette("workflow_analysis")
1761588187543:vignettes/workflow_analysis.Rmd
1761588276081:file.edit("vignettes/workflow_analysis.Rmd")
1761588300587:readLines("vignettes/workflow_analysis.Rmd")
1761588616486:devtools::build_vignettes()
1761588633276:vignette("workflow_analysis", package = "ProjectAlessandra")
1761588666168:devtools::install()
1761588679007:vignette("workflow_analysis", package = "ProjectAlessandra")
1761588733391:browseURL(system.file("doc/workflow_analysis.html", package = "ProjectAlessandra"))
1761588761862:devtools::build()
1761588770183:devtools::install()
1761588784241:vignette("workflow_analysis", package = "ProjectAlessandra")
1761588834999:browseURL(system.file("doc/workflow_analysis.html", package = "ProjectAlessandra"))
1761589072444:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761589073392:browseURL("vignettes/workflow_analysis.html")
1761589126602:devtools::build()
1761589134987:devtools::install()
1761589149544:vignette("workflow_analysis", package = "ProjectAlessandra")
1761589272669:devtools::build_vignettes()
1761589279285:devtools::install()
1761589288366:vignette("workflow_analysis", package = "ProjectAlessandra")
1761589381024:devtools::build_vignettes()
1761589389208:devtools::install()
1761589397953:vignette("workflow_analysis", package = "ProjectAlessandra")
1761589493377:unlink("doc", recursive = TRUE)
1761589493380:unlink("vignettes/*.html")
1761589500458:devtools::build_vignettes()
1761589511667:devtools::install()
1761589525472:vignette("workflow_analysis", package = "ProjectAlessandra")
1761589585733:list.files("vignettes/")
1761589608672:unlink("doc", recursive = TRUE)
1761589608676:unlink("ProjectAlessandra_*.tar.gz")
1761589623799:devtools::build_vignettes()
1761589630624:devtools::install()
1761589649982:vignette("workflow_analysis", package = "ProjectAlessandra")
1761589821428:list.files("vignettes/")
1761589828213:unlink("doc", recursive = TRUE)
1761589828219:unlink("ProjectAlessandra_*.tar.gz")
1761589834120:devtools::build_vignettes()
1761589844863:devtools::install()
1761589857525:vignette("workflow_analysis", package = "ProjectAlessandra")
1761590146793:vignette("workflow_analysis", package = "ProjectAlessandra")
1761590146799:unlink("doc", recursive = TRUE)
1761590146803:unlink("ProjectAlessandra_*.tar.gz")
1761590153906:devtools::build_vignettes()
1761590210649:vignette("workflow_analysis", package = "ProjectAlessandra")
1761590235431:unlink("doc", recursive = TRUE)
1761590235434:unlink("ProjectAlessandra_*.tar.gz")
1761590240128:devtools::build_vignettes()
1761590307725:devtools::install()
1761592448975:devtools::build_vignettes()
1761592454941:devtools::install(build_vignettes = TRUE)
1761592478601:devtools::install(build_vignettes = TRUE)
1761592491664:vignette("workflow_analysis", package = "ProjectAlessandra")
1761592604333:install.packages(c("rmarkdown", "knitr", "data.table"))
1761592617902:install.packages(c("rmarkdown", "knitr", "data.table"))
1761597703875:devtools::document()
1761597716756:devtools::load_all()
1761597800609:devtools::install()
1761597853701:library(ProjectAlessandra)
1761597864168:?final_revision_dt
1761598016645:vignette("workflow_analysis", package = "ProjectAlessandra")
1761598078375:library(ProjectAlessandra)
1761598084510:vignette("workflow_analysis", package = "ProjectAlessandra")
1761598094377:devtools::build_vignettes()
1761598100556:devtools::install(build_vignettes = TRUE)
1761598114506:vignette("workflow_analysis", package = "ProjectAlessandra")
1761598754549:mtcars
1761599210520:?data.table
1761600670949:getwd
1761600674602:getwd()
1761600841952:#CON FUNCTION:
1761600841955:result <- bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv","project_oct25/sample_metadata.csv")
1761600972413:library(data.table)
1761600972891:library(microbenchmark)
1761600973434:library(ggplot2)
1761600975742:# Task 1
1761600975744:bench1 <- microbenchmark(
1761600975746:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761600975748:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761600975749:times = 10
1761600975751:)
1761600979913:autoplot(bench1)
1761601163342:("R/dt_functions.R")
1761601188577:library(data.table)
1761601189182:library(microbenchmark)
1761601189657:library(ggplot2)
1761601190634:# carico le funzioni
1761601190637:source("R/df_functions.R")
1761601192279:source("R/dt_functions.R")
1761601198939:#CON FUNCTION:
1761601198942:result <- bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv","project_oct25/sample_metadata.csv")
1761601223966:devtools::document()
1761601237455:devtools::load_all()
1761601288039:devtools::install
1761601314108:devtools::install()
1761601670337:devtools::document()
1761601676782:devtools::document()
1761601685596:devtools::document()
1761601759774:devtools::document()
1761601964217:devtools::document()
1761601972911:warnings()
1761602147528:remove.packages("ProjectAlessandra")
1761602160062:devtools::document()
1761602172814:devtools::load_all()
1761602184519:devtools::install()
1761660477417:rmarkdown::render("vignettes/workflow_analysis.Rmd", output_format = "rmarkdown::html_vignette")
1761660507822:rmarkdown::render("vignettes/workflow_analysis.Rmd", output_format = "rmarkdown::html_vignette")
1761660974935:getdw()
1761660982079:getwd()
1761661080020:rmarkdown::render("vignettes/workflow_analysis.Rmd", output_format = "rmarkdown::html_vignette")
1761661328160:rmarkdown::render("vignettes/workflow_analysis.Rmd", output_format = "rmarkdown::html_vignette")
1761661374828:setwd("/home/rstudio")
1761661381576:rmarkdown::render("vignettes/workflow_analysis.Rmd", output_format = "rmarkdown::html_vignette")
1761661423223:getwd()
1761661515797:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761661539263:rmarkdown::render("vignettes/workflow_analysis.Rmd",
1761661539265:output_format = "rmarkdown::html_vignette")
1761661769243:rmarkdown::render("vignettes/workflow_analysis.Rmd",
1761661769250:+                   output_format = "rmarkdown::html_vignette")
1761661783744:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761661954248:install.packages("here")
1761664734118:rmarkdown::render("workflow_analysis.Rmd")
1761664775718:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761664796716:setwd("vignettes")
1761664805404:rmarkdown::render("workflow_analysis.Rmd")
1761664853245:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761664861542:setwd("vignettes")
1761664870812:rmarkdown::render("workflow_analysis.Rmd")
1761665089848:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761665135576:rmarkdown::render(here::here("vignettes", "workflow_analysis.Rmd"))
1761665144061:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761665157838:getwd()
1761665157839:list.files()
1761665157840:list.files("vignettes")
1761665370548:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761665410225:rmarkdown::render("workflow_analysis.Rmd")
1761665429085:rmarkdown::render("workflow_analysis.Rmd")
1761665441143:getwd()
1761665452689:list.files()
1761665475054:rmarkdown::render("workflow_analysis.Rmd")
1761665487785:rmarkdown::render("workflow_analysis.Rmd")
1761665519859:library(here)
1761665527836:fread(here::here("project_oct25", "bulk_counts_long.csv"))
1761665542624:rmarkdown::render("workflow_analysis.Rmd")
1761665656734:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761665668995:setwd(here::here())
1761665684916:rmarkdown::render("vignettes/workflow_analysis.Rmd")
1761665835060:rmarkdown::render(
1761665835067:input = "vignettes/workflow_analysis.Rmd",
1761665835068:output_dir = "vignettes/output",
1761665835070:envir = new.env(),
1761665835071:knit_root_dir = here::here()
1761665835073:)
1761665945198:> rmarkdown::render(
1761665961474:rmarkdown::render(
1761665961476:input = "vignettes/workflow_analysis.Rmd",
1761665961478:output_dir = "vignettes/output",
1761665961480:envir = new.env(),        # usa un ambiente pulito
1761665961484:knit_root_dir = here::here()   # importante: setta la root directory per il knit
1761665961487:)
1761667248126:non so se vuoi farlo tu o chatgpt, magari per alcune cose c'Ã¨ bisogno che lo fai tu (o io) tipo i plot, poi non so se vuoi far fare la maggior parte del testo a chat, comuqnue andrÃ  aggiustato dopo
1761667260803:io farei come ho fatto per questi, mi faccio aiutare e mano a mano li sistemo
1761667268978:mi servono delle dritte perÃ²
1761667273698:secondo me i plot li fa chat
1761667287701:secondo me proprio il plot Ã¨ easy
1761667294342:e con chat ti complichi la vita
1761667296717:vediamo
1761667311224:in che task ci sono i plot? oltre all'alaisi comparativa'
1761667324092:nella final revision mi pare task 4.1 e 5.1 e basta?
1761667329149:sisi mi pare di si
1761667332418:da 1 a 12 no?
1761667339856:da 1 a 12 mi sa che sono solo tabelle
1761667340888:ok
1761667443670:io farei che per ogni task scriverei bene la funzione, riportando il codice o no? come facciamo a capire cosa aggiungere seguirei l'ordine li quell'
1761667444099:o ok
1761667633808:quello nel file word
1761667644624:hai eliminato il file "test"? s
1761667648644:si
1761667744397:fammi uscire e rientrare
1761668449926:usethis::use_vignette("workflow_analysis")
1761686196406:?ggsave
1761686447795:devtools::document()
1761686454701:devtools::load_all()
1761686462637:devtools::install()
1761686559213:library(data.table)
1761686559552:library(microbenchmark)
1761686560163:library(ggplot2)
1761686564609:# carico le funzioni
1761686564613:source("R/df_functions.R")
1761686564944:source("R/dt_functions.R")
1761686575162:#FINAL REVISION
1761686575166:benchfr <- microbenchmark(
1761686575168:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686575169:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686575171:times = 10
1761686575173:)
1761686591299:?ggsvae
1761686595350:?ggsave
1761686629687:getwd()
1761686683220:source("R/dt_functions.R")
1761686688642:#FINAL REVISION
1761686688648:benchfr <- microbenchmark(
1761686688651:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686688654:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686688658:times = 10
1761686688661:)
1761686716398:("R/df_functions.R")
1761686721664:source("R/dt_functions.R")
1761686728364:#FINAL REVISION
1761686728369:benchfr <- microbenchmark(
1761686728371:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686728373:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686728375:times = 10
1761686728379:)
1761686912198:library(data.table)
1761686912500:library(microbenchmark)
1761686912988:library(ggplot2)
1761686913495:# carico le funzioni
1761686913497:source("R/df_functions.R")
1761686914067:source("R/dt_functions.R")
1761686920673:#FINAL REVISION
1761686920677:benchfr <- microbenchmark(
1761686920679:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686920681:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761686920684:times = 10
1761686920686:)
1761687026075:source("R/dt_functions.R")
1761687065010:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv")
1761687094323:source("R/dt_functions.R")
1761687095542:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv")
1761687125834:source("R/dt_functions.R")
1761687127114:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv")
1761687168526:?ggplot
1761687237841:devtools::document()
1761687255617:devtools::document()
1761687266120:devtools::loadall()
1761687273871:devtools::load_all()
1761687283028:devtools::install()
1761687306158:?!
1761687312408:a
1761688107248:?normalizePath
1761688224216:getwd()
1761689004299:?ggsave
1761689014616:?ggsave
1761689030582:library(ggplot2)
1761689032858:library(ggplot2)
1761689034227:?ggsave
1761689076665:devtools::document()
1761689087475:devtools::load_all()
1761689092873:devtools::install()
1761689379271:list.files("Outputs")
1761689612065:?import
1761690986038:?bulk_counts_qc_dt
1761691031177:?bulk_counts_summary_dt
1761691560150:# Task 1
1761691560153:bench1 <- microbenchmark(
1761691560156:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691560157:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691560160:times = 10
1761691560162:)
1761691583237:library(microbenchmark)
1761691585189:# Task 1
1761691585192:bench1 <- microbenchmark(
1761691585195:df_version = bulk_counts_summary_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691585196:dt_version = bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691585199:times = 10
1761691585202:)
1761691603475:autoplot(bench1)
1761691605602:# Task 2
1761691605605:bench2 <- microbenchmark(
1761691605608:df_version = bulk_counts_qc_df("project_oct25/bulk_counts_long.csv"),
1761691605609:dt_version = bulk_counts_qc_dt("project_oct25/bulk_counts_long.csv"),
1761691605611:times = 10
1761691605612:)
1761691606739:autoplot(bench2)
1761691608561:# Task 4
1761691608564:bench4 <- microbenchmark(
1761691608566:df_version = annotate_counts_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691608568:dt_version = annotate_counts_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691608570:times = 10
1761691608571:)
1761691609985:autoplot(bench4)
1761691611170:# Task 5
1761691611174:bench5 <- microbenchmark(
1761691611177:df_version = classify_labs_df("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761691611180:dt_version = classify_labs_dt("project_oct25/clinical_labs.csv", "project_oct25/lab_reference_ranges.csv"),
1761691611181:times = 10
1761691611185:)
1761691611824:autoplot(bench5)
1761691612895:# Task 6
1761691612898:bench6 <- microbenchmark(
1761691612900:df_version = match_vitals_df("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761691612902:dt_version = match_vitals_dt("project_oct25/clinical_labs.csv", "project_oct25/vitals_time_series.csv"),
1761691612903:times = 10
1761691612905:)
1761691616844:autoplot(bench6)
1761691617157:# Task 7
1761691617159:bench7 <- microbenchmark(
1761691617160:df_version = top_peaks_df("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761691617161:dt_version = top_peaks_dt("project_oct25/atac_peaks.bed.csv", "chr2", 2000000, 4000000),
1761691617162:times = 10
1761691617164:)
1761691617897:autoplot(bench7)
1761691618237:# Task 8
1761691618238:bench8 <- microbenchmark(
1761691618238:df_version = gene_stats_filter_df("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691618239:dt_version = gene_stats_filter_dt("project_oct25/bulk_counts_long.csv", "project_oct25/sample_metadata.csv"),
1761691618240:times = 10
1761691618240:)
1761691629764:autoplot(bench8)
1761691630081:# Task 9
1761691630082:bench9 <- microbenchmark(
1761691630083:df_version = wide_long_wide_df("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761691630084:dt_version = wide_long_wide_dt("project_oct25/bulk_counts_wide.csv", "project_oct25/sample_metadata.csv"),
1761691630084:times = 10
1761691630085:)
1761691632158:autoplot(bench9)
1761691632459:# Task 10
1761691632460:bench10 <- microbenchmark(
1761691632461:df_version = atac_to_gene_df("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761691632462:dt_version = atac_to_gene_dt("project_oct25/atac_peaks.bed.csv", "project_oct25/gene_annotation.bed.csv"),
1761691632463:times = 10
1761691632464:)
1761691652398:autoplot(bench10)
1761691652718:# Task 11
1761691652719:bench11 <- microbenchmark(
1761691652720:df_version = variants_to_genes_df("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761691652721:dt_version = variants_to_genes_dt("project_oct25/variants.csv", "project_oct25/gene_annotation.bed.csv"),
1761691652722:times = 10
1761691652723:)
1761691661133:autoplot(bench11)
1761691661449:# Task 12
1761691661450:bench12 <- microbenchmark(
1761691661451:df_version = combine_cohorts_df("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761691661452:dt_version = combine_cohorts_dt("project_oct25/cohortA_samples.csv", "project_oct25/cohortB_samples.csv","project_oct25/bulk_counts_long.csv"),
1761691661453:times = 10
1761691661454:)
1761691663055:autoplot(bench12)
1761691663393:#FINAL REVISION
1761691663394:benchfr <- microbenchmark(
1761691663394:df_version = final_revision_df("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761691663395:dt_version = final_revision_dt ("project_oct25/annotated_GSM3516673_normal_annotated_GSM3516672_tumor_SeuratIntegration.csv", "project_oct25/nt_combined_clustering.output.csv"),
1761691663396:times = 10
1761691663396:)
1761691681327:autoplot(benchfr)
1761691681666:results <- rbindlist(list(
1761691681667:task1 = as.data.table(bench1),
1761691681668:task2 = as.data.table(bench2),
1761691681669:task4 = as.data.table(bench4),
1761691681670:task5 = as.data.table(bench5),
1761691681670:task6 = as.data.table(bench6),
1761691681671:task7 = as.data.table(bench7),
1761691681672:task8 = as.data.table(bench8),
1761691681673:task9 = as.data.table(bench9),
1761691681674:task10 = as.data.table(bench10),
1761691681674:task11 = as.data.table(bench11),
1761691681675:task12 = as.data.table(bench12),
1761691681676:final_revision = as.data.table(benchfr)
1761691681676:), idcol = "task")[, .(df_mean = mean(time[expr=="df_version"])/1e6,
1761691681677:dt_mean = mean(time[expr=="dt_version"])/1e6),
1761691681679:by = task]
1761691705128:library(data.table)
1761691708965:results <- rbindlist(list(
1761691708968:task1 = as.data.table(bench1),
1761691708970:task2 = as.data.table(bench2),
1761691708972:task4 = as.data.table(bench4),
1761691708975:task5 = as.data.table(bench5),
1761691708978:task6 = as.data.table(bench6),
1761691708981:task7 = as.data.table(bench7),
1761691708984:task8 = as.data.table(bench8),
1761691708985:task9 = as.data.table(bench9),
1761691708988:task10 = as.data.table(bench10),
1761691708990:task11 = as.data.table(bench11),
1761691708992:task12 = as.data.table(bench12),
1761691708994:final_revision = as.data.table(benchfr)
1761691708997:), idcol = "task")[, .(df_mean = mean(time[expr=="df_version"])/1e6,
1761691708999:dt_mean = mean(time[expr=="dt_version"])/1e6),
1761691709001:by = task]
1761691716995:View(results)
1761691976903:?outoplot
1761691986002:library(ggplot2)
1761691988054:?outoplot
1761692004710:?autoplot
1761693878729:library(ggplot2)
1761693893493:devtools::document()
1761693900796:devtools::load_all()
1761693907563:devtools::install()
1761747868483:# 1. Import
1761747868487:bulk_counts <- fread("project_oct25/bulk_counts_long.csv")
1761747868895:sample_meta   <- fread("project_oct25/sample_metadata.csv")
1761747870075:View(bulk_counts)
1761747881240:View(sample_meta)
1761748961411:#' Classify lab values against reference intervals
1761748961417:#'
1761748961420:#' Merges patient lab results with reference intervals and assigns each test
1761748961426:#' as "normal" or "out_of_range", and summarizes abnormalities per patient and per lab.
1761748961429:#'
1761748961431:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761748961433:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761748961436:#' @return List with merged_labs, abnormal_by_patient, abnormal_by_lab.
1761748961443:#' @import data.table
1761748961454:#' @export
1761748961459:classify_labs_dt <- function(labs_path, ref_path) {
1761748961466:labs <- fread(labs_path)
1761748961467:ref  <- fread(ref_path)
1761748961469:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761748961471:merged_labs <- merge(labs, ref_unique, by = "lab")
1761748961474:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761748961476:abnormal_by_patient <- merged_labs[, .(
1761748961478:total_tests = .N,
1761748961479:out_of_range = sum(status == "out_of_range")
1761748961480:), by = patient_id]
1761748961482:abnormal_by_lab <- merged_labs[, .(
1761748961483:total_tests = .N,
1761748961484:out_of_range = sum(status == "out_of_range")
1761748961485:), by = lab]
1761748961488:return(list(merged_labs = merged_labs, abnormal_by_patient = abnormal_by_patient, abnormal_by_lab = abnormal_by_lab))
1761748961489:}
1761748963044:#'
1761748963048:#' Performs "rolling join" to match the closest available heart rate (HR)
1761748963049:#' and systolic blood pressure (SBP) to each lab test times for the same patient.
1761748963051:#' Computes per-patient correlations between CRP (C-reactive protein) and vitals.
1761748963052:#'
1761748963053:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761748963054:#' @param vitals_path Path to CSV file with columns: time_iso
1761748963055:#' @return List with labs_with_vitals and correlations (CRP vs HR/SBP)
1761748963056:#' @import data.table
1761748963057:#' @export
1761748963058:match_vitals_dt <- function(labs_path, vitals_path) {
1761748963061:labs <- fread(labs_path)
1761748963063:vitals <- fread(vitals_path)
1761748963066:labs[, time_iso := as.POSIXct(time_iso)]
1761748963069:vitals[, time_iso := as.POSIXct(time_iso)]
1761748963073:setorder(labs, patient_id, time_iso)
1761748963075:setorder(vitals, patient_id, time_iso)
1761748963080:labs[, lab_time := time_iso]
1761748963081:setkey(labs, patient_id, time_iso)
1761748963082:setkey(vitals, patient_id, time_iso)
1761748963086:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)]
1761748963089:setnames(vitals_hr, "value", "nearest_HR")
1761748963095:vitals_hr[, hr_time := time_iso]
1761748963096:setkey(vitals_hr, patient_id, time_iso)
1761748963100:labs_with_hr <- vitals_hr[labs, roll = "nearest"]
1761748963102:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761748963103:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761748963104:setnames(vitals_sbp, "value", "nearest_SBP")
1761748963106:vitals_sbp[, sbp_time := time_iso]
1761748963106:setkey(vitals_sbp, patient_id, time_iso)
1761748963108:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761748963108:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761748963111:crp_data <- labs_with_vitals[lab == "CRP"]
1761748963113:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761748963114:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761748963116:), by = patient_id]
1761748963118:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761748963119:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761748963120:), by = patient_id]
1761748963122:return(list(labs_with_hr = labs_with_hr, labs_with_vitals=labs_with_vitals, cor_crp_hr = cor_crp_hr, cor_crp_sbp = cor_crp_sbp))
1761748963123:}
1761748970780:# 1 Carico i file
1761748970785:labs <- fread("project_oct25/clinical_labs.csv")
1761748971283:ref  <- fread("project_oct25/lab_reference_ranges.csv")
1761748973470:View(labs)
1761748990727:View(ref)
1761749147745:# Unisco le tabelle per aggiungere i range di riferimento
1761749147748:# Dato che i range sono uguali per M e F, li prendo una sola volta
1761749147750:ref_unique <- unique(ref[, .(lab, lower, upper)])
1761749148029:# Uso una join per aggiungere a ogni valore clinico i limiti lower e upper del test corrispondente
1761749148050:merged_labs <- merge(labs, ref_unique, by = "lab")
1761749148230:# -----------------------------------------------------
1761749148233:# PARTE 2: Classifico i valori come "normal" o "out_of_range"
1761749148236:# -----------------------------------------------------
1761749148238:merged_labs[, status := ifelse(value >= lower & value <= upper, "normal", "out_of_range")]
1761749148964:# -----------------------------------------------------
1761749148966:# PARTE 3: Calcolo la percentuale di risultati fuori range per paziente
1761749148970:# -----------------------------------------------------
1761749148976:abnormal_by_patient <- merged_labs[, .(
1761749148977:total_tests = .N,                                 # numero totale di test per paziente
1761749148978:out_of_range = sum(status == "out_of_range")      # quanti sono fuori range
1761749148983:), by = patient_id]
1761749149508:# -----------------------------------------------------
1761749149517:# PARTE 4: Calcolo i risultati fuori range per tipo di test
1761749149520:# -----------------------------------------------------
1761749149523:abnormal_by_lab <- merged_labs[, .(
1761749149525:total_tests = .N,
1761749149527:out_of_range = sum(status == "out_of_range")
1761749149528:), by = lab]
1761749152985:View(abnormal_by_lab)
1761749167095:View(abnormal_by_lab)
1761749178229:View(abnormal_by_patient)
1761749194797:View(merged_labs)
1761749809689:#Goal: Slice genomics windows efficiently. Data: atac_peaks.bed.csv
1761749809691:#Tasks:
1761749809692:#â€¢ Extract peaks on chr2 with start between 2 and 4 Mb.
1761749809693:#â€¢ Among those peaks, return the top 50 by score after setorder() (descending)
1761749809695:# Carico la libreria
1761749809696:library(data.table)
1761749809698:# Leggo il file dei picchi ATAC
1761749809698:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761749809735:# Filtro i picchi su chr2 e nella finestra 2â€“4 Mb
1761749809737:# Nota: 1 Mb = 1.000.000 basi
1761749809738:subset_peaks <- peaks[chr == "chr2" & start >= 2000000 & start <= 4000000]
1761749809743:#Ordino i picchi per punteggio decrescente
1761749809745:subset_peaks <- setorder(subset_peaks, -score)
1761749809749:#Prendo i primi 50 picchi
1761749809752:top50_peaks <- head(subset_peaks, 50)
1761749809756:result <- top_peaks_dt("project_oct25/atac_peaks.bed.csv","chr2", 2000000,4000000)
1761749818712:View(subset_peaks)
1761749820213:View(top50_peaks)
1761750018542:View(top50_peaks)
1761750034921:# =====================================================
1761750034924:# Goal: Nearest-time matching of vitals to lab draws. Data: clinical_labs.csv, vitals_time_series.csv Tasks:
1761750034925:#â€¢ For each lab measurement, attach the nearest HR and SBP reading using a rolling join on (patient_id, time)
1761750034926:#and report the time lag in minutes.
1761750034928:#â€¢ Summarize correlation between CRP and nearest HR/SBP by patient.
1761750034929:#si lavora su dati di pazienti, si introducono misurazioni reali nel tempo,
1761750034931:#si usano strumenti â€œtemporaliâ€ come il rolling join per trovare misure vicine nel tempo.
1761750034936:#TASK 6: Nearest-time matching of vitals to lab draws
1761750034940:# =====================================================
1761750034940:library(data.table)
1761750034942:# 1. Carico i dati
1761750034943:labs <- fread("project_oct25/clinical_labs.csv")
1761750034947:vitals <- fread("project_oct25/vitals_time_series.csv")
1761750034951:# 2. Preparo le tabelle e converte le date in un formato tempo che R puÃ² confrontare
1761750034952:labs[, time_iso := as.POSIXct(time_iso)]
1761750034954:vitals[, time_iso := as.POSIXct(time_iso)]
1761750034956:#ordina i dati per paziente e per tempo, serve per i join temporali
1761750034957:setorder(labs, patient_id, time_iso)
1761750034959:setorder(vitals, patient_id, time_iso)
1761750034961:# Salvo il tempo del laboratorio, creando una nuova colonna lab_time con l'orario del prelievo
1761750034962:labs[, lab_time := time_iso]
1761750034964:#imposto le chiavi, importante per il join
1761750034965:setkey(labs, patient_id, time_iso)
1761750034966:setkey(vitals, patient_id, time_iso)
1761750034968:# 3. Trovo l'HR piÃ¹ vicino
1761750034969:vitals_hr <- vitals[vital == "HR", .(patient_id, time_iso, value)] #prendo solo le righe dei HR
1761750034974:setnames(vitals_hr, "value", "nearest_HR") #rinomino la colonna value in nearest HR
1761750034975:# SALVO IL TEMPO DELL'HR PRIMA DEL JOIN!
1761750034976:vitals_hr[, hr_time := time_iso] #salvo l'ora della misura HR
1761750034978:setkey(vitals_hr, patient_id, time_iso)
1761750034979:labs_with_hr <- vitals_hr[labs, roll = "nearest"] #rolling join
1761750034982:#per ogni esame di lab, trova il battito HR piÃ¹ vicino nel tempo x lo stesso paziente
1761750034982:labs_with_hr[, hr_lag_minutes := as.numeric(difftime(lab_time, hr_time, units = "mins"))]
1761750034984:#calcola la differenza temporale in minuti tra prelievo e battito
1761750034986:# 4. Trovo l'SBP piÃ¹ vicino, esattamente lo stesso per pressione
1761750034987:vitals_sbp <- vitals[vital == "SBP", .(patient_id, time_iso, value)]
1761750034990:setnames(vitals_sbp, "value", "nearest_SBP")
1761750034991:# SALVO IL TEMPO DELL'SBP PRIMA DEL JOIN!
1761750034992:vitals_sbp[, sbp_time := time_iso]
1761750034994:setkey(vitals_sbp, patient_id, time_iso)
1761750034996:labs_with_vitals <- vitals_sbp[labs_with_hr, roll = "nearest"]
1761750034998:labs_with_vitals[, sbp_lag_minutes := as.numeric(difftime(lab_time, sbp_time, units = "mins"))]
1761750035001:# 6. Analisi CRP: filtra solo le righe dove il lab Ã¨ CRP
1761750035002:crp_data <- labs_with_vitals[lab == "CRP"]
1761750035005:#per ogni paziente (by sample id) calcola la correlazione tra CRP e battito e CRP e pressione
1761750035006:#complete.obs: ignora le righe con dati mancanti
1761750035007:cor_crp_hr <- crp_data[!is.na(nearest_HR), .(
1761750035008:correlation_CRP_HR = cor(value, nearest_HR, use = "complete.obs")
1761750035009:), by = patient_id]
1761750035013:cor_crp_sbp <- crp_data[!is.na(nearest_SBP), .(
1761750035014:correlation_CRP_SBP = cor(value, nearest_SBP, use = "complete.obs")
1761750035015:), by = patient_id]
1761750047940:View(cor_crp_sbp)
1761750160883:#Goal: Multi-column operations per group.
1761750160891:#Data: bulk_counts_long.csv, sample_metadata.csv
1761750160898:#Tasks:
1761750160900:#â€¢ Compute per-condition robust summary stats for each gene: mean, median, Q1/Q3.
1761750160903:#â€¢ Return only genes where treated mean â€šÃ¢â€¢ 2âˆšÃ³ control mean.
1761750160905:library(data.table)
1761750160912:counts <- fread("project_oct25/bulk_counts_long.csv")
1761750160919:meta   <- fread("project_oct25/sample_metadata.csv")
1761750160926:#unione di counts e metadata per avere la colonna 'condition' insieme ai conteggi
1761750160927:merged <- counts[meta, on = "sample_id"]
1761750160932:#Calcoliamo le statistiche per gene e condition: mean, median, Q1 (25%) e Q3 (75%)
1761750160933:stats_by_gene_condition <- merged[, .(
1761750160934:mean_count   = mean(count),
1761750160934:median_count = median(count),
1761750160935:Q1           = quantile(count, 0.25, type = 2),
1761750160936:Q3           = quantile(count, 0.75, type = 2)
1761750160937:), by = .(gene, condition)]
1761750161381:#Per applicare la regola "treated mean >= 2 * control mean" serve una tabella wide con le medie:
1761750161382:#separiamo le medie per condition e poi facciamo un merge per gene.
1761750161383:treated_means <- stats_by_gene_condition[condition == "treated", .(gene, treated_mean = mean_count)]
1761750161386:control_means <- stats_by_gene_condition[condition == "control", .(gene, control_mean = mean_count)]
1761750161390:#Uniamo le due tabelle delle medie per avere una riga per gene con entrambe le medie
1761750161390:means_wide <- merge(treated_means, control_means, by = "gene", all = FALSE)
1761750161394:# all = FALSE -> keep only genes present in both (necessario per confronto)
1761750161395:#Applichiamo il filtro: kept genes dove treated_mean >= 2 * control_mean
1761750161396:kept_genes <- means_wide[treated_mean >= 2 * control_mean]
1761750181073:View(stats_by_gene_condition)
1761750182423:View(kept_genes)
1761751478768:# Carichiamo le librerie
1761751478772:library(data.table)
1761751479056:# Leggiamo i dati (matrice larga: una riga per gene, una colonna per campione)
1761751479060:counts_wide <- fread("project_oct25/bulk_counts_wide.csv")
1761751484444:# Aggiungiamo le informazioni di condizione per ogni sample
1761751484446:# Carichiamo i metadati
1761751484450:meta <- fread("project_oct25/sample_metadata.csv")
1761751486002:View(counts_wide)
1761751504580:#Goal: Go wideâ€š to longâ€š to wide for downstream plotting. Data: bulk_counts_wide.csv
1761751504586:#Tasks:
1761751504589:# â€¢ Convert the matrix to long, add per-sample totals, then back to a gene per condition table with mean counts.
1761751504603:# =====================================================
1761751504605:# TASK 9: Go wide â†’ long â†’ wide for downstream plotting
1761751504606:# =====================================================
1761751504612:# Carichiamo le librerie
1761751504615:library(data.table)
1761751504620:# Leggiamo i dati (matrice larga: una riga per gene, una colonna per campione)
1761751504621:counts_wide <- fread("project_oct25/bulk_counts_wide.csv")
1761751504634:# PARTE 1: Convertiamo da formato wide â†’ long
1761751504635:# -----------------------------------------------------
1761751504636:# Supponiamo che la prima colonna si chiami "gene"
1761751504637:counts_long <- melt(counts_wide, id.vars = "gene",
1761751504638:variable.name = "sample_id", value.name = "count")
1761751504640:#melt()	scioglie la tabella da larga a lunga.
1761751504641:#counts_wide	Ã¨ la tabella di partenza (quella larga).
1761751504642:#id.vars = "gene"	dice a R: mantieni la colonna â€œgeneâ€ cosÃ¬ comâ€™Ã¨ (non la trasformare).
1761751504643:#Tutte le altre colonne (sample_1, sample_2, ecc.) verranno â€œsciolteâ€.
1761751504644:#variable.name = "sample_id"	dÃ  un nome alla nuova colonna che conterrÃ  i nomi delle vecchie colonne (cioÃ¨ i nomi dei campioni)
1761751504645:#value.name = "count"	dÃ  un nome alla colonna che conterrÃ  i valori numerici (cioÃ¨ i conteggi per gene e campione).
1761751504646:# Aggiungiamo le informazioni di condizione per ogni sample
1761751504647:# Carichiamo i metadati
1761751504648:meta <- fread("project_oct25/sample_metadata.csv")
1761751504650:# Uniamo metadati ai conteggi
1761751504651:merged <- merge(counts_long, meta, by = "sample_id")
1761751504664:# Calcoliamo i totali per campione
1761751504664:totals_per_sample <- merged[, .(total_count = sum(count)), by = sample_id]
1761751504669:# Aggiungiamo questi totali alla tabella principale
1761751504669:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761751504675:# Torniamo da long â†’ wide,
1761751504676:#           ma ora con colonne per condizione (treated, control)
1761751504676:#           e valori = media dei conteggi per gene
1761751504677:gene_condition_means <- merged[, .(mean_count = mean(count)),
1761751504678:by = .(gene, condition)]
1761751504683:# Da long a wide: una riga per gene, colonne = condizioni
1761751504683:counts_condition_wide <- dcast(gene_condition_means,
1761751504684:gene ~ condition,
1761751504685:value.var = "mean_count")
1761751529442:View(counts_condition_wide)
1761751820536:#Goal: Map SNPs to genes.
1761751820541:#Data: variants.csv, gene_annotation.bed.csv
1761751820543:#Tasks:
1761751820545:#â€¢ Convert variant positions to 1-bp intervals (pos, pos)
1761751820546:#and find overlaps with gene intervals.
1761751820548:#â€¢ Summarize counts of HIGH impact variants by gene and by sample.
1761751820549:#â€¢ List genes with HIGH-impact variants across all samples.
1761751820551:#Obiettivo:
1761751820552:#mappare le varianti (SNP) sui geni
1761751820554:#contare le varianti ad alto impatto (HIGH) per gene e per campione
1761751820555:#ottenere la lista dei geni che presentano almeno una variante HIGH in qualsiasi campione
1761751820557:# carico la libreria
1761751820558:library(data.table)
1761751820561:# leggo i file
1761751820562:variants <- fread("project_oct25/variants.csv")
1761751820573:genes    <- fread("project_oct25/gene_annotation.bed.csv")
1761751820579:# Creo intervalli 1-bp per le varianti: start = pos, end = pos
1761751820580:#    (foverlaps lavora con intervalli start-end)
1761751820581:variants[, start := pos]  #creo per ogni variante un intervallo 1bp
1761751820585:variants[, end   := pos]  #foverlaps () lavora con intervalli start-end quindi gli servono
1761751820591:# 5) imposto le chiavi per foverlaps: (chr, start, end), requisito per foverlaps utile per velocizzare
1761751820592:setkey(variants, chr, start, end)
1761751820605:setkey(genes,    chr, start, end)
1761751820617:# 6) eseguo l'overlap: trovo per ogni variante i geni che si sovrappongono
1761751820618:#    nomatch = 0L rimuove le varianti senza overlap, che non sovrappongono alcun gene
1761751820640:overlaps <- foverlaps(variants, genes, type = "any", nomatch = 0L)
1761751820673:#type any cioÃ¨ prende qualsiasi sovrapposizione (parziale o completa)
1761751820686:# 7) filtro le varianti di alto impatto (impact == "HIGH")
1761751820688:#    normalizzo il valore di impact a maiuscole per sicurezza
1761751820690:overlaps[, impact_upper := toupper(impact)] #normalizzo il campo impact
1761751820694:#overlaps	Ãˆ il nome della tabella su cui stai lavorando (una data.table).
1761751820695:#[,]	In data.table, serve per dire â€œfai qualcosa su questa tabellaâ€.
1761751820696:#impact_upper := ...	Con := stai creando una nuova colonna chiamata impact_upper, oppure sovrascrivendo se giÃ  esiste.
1761751820697:#toupper(impact)	Ãˆ una funzione di R che trasforma tutto il testo in maiuscolo prendendo i valori della colonna impact.
1761751820698:high_overlaps <- overlaps[impact_upper == "HIGH"] #seleziono solo le varianti con impact HIGH
1761751820705:# 8) conto le varianti HIGH per gene e per sample_id
1761751820706:#conta quante varianti ci sono per coppia gene x sample_id
1761751820707:#.N Ã¨ il conteggio delle righe del gruppo
1761751820708:high_counts_by_gene_sample <- high_overlaps[, .(
1761751820709:high_variant_count = .N
1761751820710:), by = .(gene, sample_id)]
1761751820727:# 9) conto le varianti HIGH per gene (tutte le sample aggregate)
1761751820736:high_counts_by_gene <- high_overlaps[, .(
1761751820737:total_high_variants = .N
1761751820738:), by = gene][order(-total_high_variants)]
1761751820752:#conta quanti HIGH per gene complessivamente e ordina decrescente i geni
1761751820756:# 10) lista dei geni che hanno almeno una variante HIGH (unique gene)
1761751820756:#Estrae i geni con almeno una variante HIGH
1761751820757:genes_with_high <- unique(high_counts_by_gene$gene)
1761751820758:print(genes_with_high)
1761751820760:# 11) (Opzionale) salvo i risultati su file CSV nella cartella project_oct25
1761751820761:fwrite(high_counts_by_gene_sample, "project_oct25/high_variants_by_gene_sample.csv")
1761751820762:fwrite(high_counts_by_gene, "project_oct25/high_variants_by_gene_total.csv")
1761751820763:fwrite(data.table(gene = genes_with_high), "project_oct25/genes_with_high_variants.csv")
1761751849258:View(high_counts_by_gene)
1761751851355:View(high_counts_by_gene_sample)
1761751854138:View(genes)
1761751856576:View(high_overlaps)
1761836941194:result <- annotate_counts_dt("project_oct25/bulk_counts_long.csv","project_oct25/sample_metadata.csv")
1761836957747:patient_tot <- result$patient_tot
1761836959180:top10 <- result$top10
1761836961243:View(top10)
1761837004118:?knitr
1761837011269:?knitr::kable
1761837060748:View(patient_tot)
1761837323834:?cor
1761840482231:usethis::use_git()
1761840772392:usethis::use_git_config(
1761840772396:user.name  = "dev-sandram",
1761840772398:user.email = "alessandramonte050@gmail.com"
1761840772399:)
1761840808270:usethis::use_git()
1761840897654:usethis::use_github()
1761840921916:gh_token_help()
1761841319398:usethis::use_github()
1761841367832:usethis::create_github_token()
1761841589360:gitcreds::gitcreds_set()
1761841630187:gitcreds::gitcreds_set()
1761841705227:gitcreds::gitcreds_set()
1761841757079:gitcreds::gitcreds_delete()
1761841774860:?data.table
1761841826690:gitcreds::gitcreds_set()
1761841854638:usethis::use_github()
1761841994156:usethis::use_readme_md()
1761843310352:## ProjectAlessandra
1761843310356:[![R-CMD-check](https://github.com/dev-sandram/ProjectAlessandra/workflows/R-CMD-check/badge.svg)](https://github.com/dev-sandram/ProjectAlessandra/actions)
1761843325255:<!-- badges: start -->
1761843332656:## ProjectAlessandra
1761843333850:ProjectAlessandra is an R package designed to provide a unified, reproducible framework for **multi-omics data analysis** â€” including bulk RNA-seq, clinical, ATAC-seq, variant, and single-cell integration datasets - and benchmarking.
1761843339207:## ProjectAlessandra
1761843339209:ProjectAlessandra is an R package designed to provide a unified, reproducible framework for **multi-omics data analysis** â€” including bulk RNA-seq, clinical, ATAC-seq, variant, and single-cell integration datasets - and benchmarking.
1761843346205:## ProjectAlessandra
1761843346208:ProjectAlessandra is an R package designed to provide a unified, reproducible framework for **multi-omics data analysis** â€” including bulk RNA-seq, clinical, ATAC-seq, variant, and single-cell integration datasets - and benchmarking.
1761843443733:git add README.md
1761845135940:# ==========================================================
1761845135943:# df_functions.R
1761845135945:# Generalized and reusable base R (data.frame) functions
1761845135947:# for bulk RNA-seq processing and summarization
1761845135948:# ==========================================================
1761845135950:# ----------------------------------------------------------
1761845135951:# TASK 1 â€“ Merge, filter, summarize, and compute per-condition means
1761845135953:# ----------------------------------------------------------
1761845135954:#' Summarize bulk RNA counts with metadata
1761845135956:#'
1761845135957:#' This function reads in raw bulk RNA-seq counts and metadata,
1761845135958:#' it merges bulk RNA-seq count data with sample metadata by "sample_id",
1761845135960:#' filters treated samples whose gene names start with "GENE_00",
1761845135961:#' and computes multiple summary statistics:
1761845135962:#' mean/median counts per gene as well as per-condition mean counts.
1761845135965:#' Designed for quick quality control and exploratory summaries using data.table's fast aggregation capabilities.
1761845135966:#'
1761845135968:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761845135971:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761845135973:#' @return none
1761845135975:#' @export
1761845135976:bulk_counts_summary_df <- function(counts_path, meta_path) {
1761845135978:# 1. Import
1761845135980:counts <- read.csv(counts_path)
1761845135982:meta   <- read.csv(meta_path)
1761845135988:# 2. Join counts + metadata by sample_id
1761845135990:merged_data <- merge(counts, meta, by = "sample_id")
1761845135992:# 3. Filter for treated samples and GENE_00* genes
1761845135993:treated_data <- subset(merged_data,
1761845135994:condition == "treated" & grepl("^GENE_00", gene))
1761845135998:# 4. Compute mean and median per gene
1761845135999:gene_summary <- aggregate(
1761845136001:count ~ gene,
1761845136003:data = treated_data,
1761845136005:FUN  = function(x) c(mean = mean(x), median = median(x))
1761845136006:)
1761845136008:# 5. Simplify format
1761845136009:gene_summary_df <- data.frame(
1761845136011:gene = gene_summary$gene,
1761845136013:mean_count   = gene_summary$count[, "mean"],
1761845136015:median_count = gene_summary$count[, "median"]
1761845136017:)
1761845136019:# 6 Calcolo della media dei conteggi per ciascun gene e condizione
1761845136021:# aggregate() calcola una funzione (mean) per gruppi
1761845136022:gene_condition_means_f <- aggregate(
1761845136023:count ~ gene + condition,   # formula: raggruppa per gene e condition
1761845136024:data = merged_data,         # tabella di partenza
1761845136025:FUN = mean,                 # funzione da applicare
1761845136026:na.rm = TRUE                # ignora eventuali valori mancanti
1761845136027:)
1761845136029:# 7 Ordina i risultati per gene e condition (per leggibilitÃ )
1761845136030:gene_condition_means_f <- gene_condition_means_f[order(gene_condition_means_f$gene,
1761845136031:gene_condition_means_f$condition), ]
1761845136032:}
1761845136034:# ----------------------------------------------------------
1761845136035:# TASK 2 â€“ Add log2(count + 1) and binary flags
1761845136036:# ----------------------------------------------------------
1761845136037:#' Add QC-style derived columns
1761845136038:#'
1761845136038:#' Computes log2-transformed counts and adds a binary \code{high} flag
1761845136039:#' indicating whether a count is above the gene-wise median.
1761845136040:#' This mimics typical preprocessing steps in QC pipelines to visualize
1761845136041:#' count distributions and detect outliers.
1761845136041:#'
1761845136042:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761845136043:#' @return none
1761845136044:#' @export
1761845136045:bulk_counts_qc_df <- function(counts_path) {
1761845136045:# 1. Import
1761845136046:counts <- read.csv(counts_path)
1761845136048:# 2. Add log2(count + 1) column
1761845136048:counts$log2_count <- log2(counts$count + 1)
1761845136050:# 3. Add binary flag 'high' (count > 100)
1761845136051:counts$high <- counts$count > 100
1761845136052:# 4. Overwrite 'high' using gene-wise median threshold
1761845136053:#    Qui usiamo tapply() per calcolare la mediana per gene,
1761845136053:#    poi combiniamo i risultati in un vettore logico della stessa lunghezza
1761845136054:medians_by_gene <- tapply(counts$count, counts$gene, median)
1761845136054:counts$high <- counts$count > medians_by_gene[counts$gene]
1761845136055:}
1761845136057:#-----------------------------------------------------------
1761845136057:#Task 3 non ha la funzione perchÃ¨ ha senso solo in data.table
1761845136058:#-----------------------------------------------------------
1761845136059:# ----------------------------------------------------------
1761845136060:# TASK 4 â€“ Filter genes by thresholded normalized expression
1761845136061:# ----------------------------------------------------------
1761845136061:#' Annotate counts with metadata and compute summaries
1761845136062:#'
1761845136062:#' Adds patient metadata to bulk counts, computes per-patient total counts,
1761845136063:#' per-gene means by condition, and identifies top 10 genes per condition
1761845136064:#' ranked by average expression.
1761845136064:#'
1761845136065:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761845136066:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761845136066:#' @return none
1761845136067:#' @export
1761845136067:annotate_counts_df <- function(counts_path, meta_path) {
1761845136068:counts <- read.csv(counts_path)
1761845136069:meta   <- read.csv(meta_path, stringsAsFactors = FALSE)
1761845136070:# 2. Join
1761845136071:merged_data <- merge(counts, meta, by = "sample_id")
1761845136072:# 3. Total counts per patient
1761845136072:patient_totals <- aggregate(count ~ patient_id, data = merged_data, FUN = sum)
1761845136073:names(patient_totals)[2] <- "total_count"
1761845136074:# 4. Mean count per gene and condition
1761845136075:gene_means <- aggregate(count ~ gene + condition, data = merged_data, FUN = mean)
1761845136075:names(gene_means)[3] <- "mean_count"
1761845136077:# 5. Top 10 genes by condition
1761845136077:conditions <- unique(gene_means$condition)
1761845136078:top10_by_condition <- data.frame()
1761845136079:for (cond in conditions) {
1761845136080:subset_cond <- subset(gene_means, condition == cond)
1761845136081:subset_cond <- subset_cond[order(-subset_cond$mean_count), ]
1761845136082:top10 <- head(subset_cond, 10)
1761845136083:top10_by_condition <- rbind(top10_by_condition, top10)}
1761845136083:}
1761845136085:# ----------------------------------------------------------
1761845136085:# TASK 5 â€“ Summary table by condition and gene class
1761845136086:# ----------------------------------------------------------
1761845136086:#' Classify lab values against reference intervals
1761845136087:#'
1761845136088:#' Merges patient lab results with reference intervals and assigns each test
1761845136088:#' as "normal" or "out_of_range", and summarizes abnormalities per patient and per lab.
1761845136089:#'
1761845136089:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761845136090:#' @param ref_path Path to CSV file with columns: lab, sex,lower, upper.
1761845136090:#' @return none
1761845136091:#' @export
1761845136091:classify_labs_df <- function(labs_path, ref_path) {
1761845136092:# 1. Import
1761845136092:labs <- read.csv(labs_path)
1761845136093:ref  <- read.csv(ref_path)
1761845136094:# 2. Keep unique reference intervals
1761845136094:ref_unique <- unique(ref[, c("lab", "lower", "upper")])
1761845136095:# 3. Join
1761845136096:merged_labs <- merge(labs, ref_unique, by = "lab")
1761845136097:# 4. Classify as normal/out_of_range
1761845136097:merged_labs$status <- ifelse(merged_labs$value >= merged_labs$lower &
1761845136098:merged_labs$value <= merged_labs$upper,
1761845136099:"normal", "out_of_range")
1761845136100:# 5. Summaries
1761845136100:abnormal_by_patient <- aggregate(status ~ patient_id, data = merged_labs,
1761845136101:FUN = function(x) {
1761845136101:total <- length(x)
1761845136102:out   <- sum(x == "out_of_range")
1761845136102:c(total_tests = total, out_of_range = out)
1761845136103:})
1761845136104:# split matrix-like column into two numeric columns
1761845136105:abnormal_by_patient$total_tests  <- abnormal_by_patient$status[, "total_tests"]
1761845136106:abnormal_by_patient$out_of_range <- abnormal_by_patient$status[, "out_of_range"]
1761845136106:abnormal_by_patient$status <- NULL
1761845136107:abnormal_by_lab <- aggregate(status ~ lab, data = merged_labs,
1761845136108:FUN = function(x) {
1761845136109:total <- length(x)
1761845136109:out   <- sum(x == "out_of_range")
1761845136110:c(total_tests = total, out_of_range = out)
1761845136110:})
1761845136112:abnormal_by_lab$total_tests  <- abnormal_by_lab$status[, "total_tests"]
1761845136112:abnormal_by_lab$out_of_range <- abnormal_by_lab$status[, "out_of_range"]
1761845136113:abnormal_by_lab$status <- NULL
1761845136114:}
1761845136116:# ----------------------------------------------------------
1761845136116:# TASK 6 â€“ Compute fold change between treated and control
1761845136117:# ----------------------------------------------------------
1761845136118:#' Nearest-time matching of vitals and labs
1761845136118:#'
1761845136119:#' Matches nearest HR/SBP readings, vital signs, to each lab time and computes correlations.
1761845136120:#'
1761845136121:#' Performs "rolling join" to match the closest available heart rate (HR)
1761845136121:#' and systolic blood pressure (SBP) to each lab test times for the same patient.
1761845136122:#' Computes per-patient correlations between CRP (C-reactive protein) and vitals.
1761845136122:#'
1761845136123:#' @param labs_path Path to CSV file with columns: patient_id, time_iso, lab, value.
1761845136123:#' @param vitals_path Path to CSV file with columns: time_iso
1761845136124:#' @return none
1761845136125:#' @export
1761845136125:match_vitals_df <- function(labs_path, vitals_path) {
1761845136126:# 1. Import
1761845136126:labs   <- read.csv(labs_path)
1761845136127:vitals <- read.csv(vitals_path)
1761845136128:# 2. Convert to POSIXct
1761845136128:labs$time_iso   <- as.POSIXct(labs$time_iso)
1761845136129:vitals$time_iso <- as.POSIXct(vitals$time_iso)
1761845136130:# 3. Join nearest HR/SBP manually (loop-based)
1761845136130:nearest_match <- function(lab_df, vitals_df, vital_type) {
1761845136131:vitals_sub <- vitals_df[vitals_df$vital == vital_type, ]
1761845136132:results <- list()
1761845136132:for (i in seq_len(nrow(lab_df))) {
1761845136133:pid <- lab_df$patient_id[i]
1761845136134:time <- lab_df$time_iso[i]
1761845136134:v_sub <- vitals_sub[vitals_sub$patient_id == pid, ]
1761845136135:if (nrow(v_sub) > 0) {
1761845136135:idx <- which.min(abs(difftime(v_sub$time_iso, time, units = "mins")))
1761845136136:results[[i]] <- v_sub[idx, c("value", "time_iso")]
1761845136137:} else {
1761845136137:results[[i]] <- data.frame(value = NA, time_iso = NA)
1761845136138:}
1761845136139:}
1761845136139:out <- do.call(rbind, results)
1761845136140:names(out) <- c(paste0("nearest_", vital_type), paste0(vital_type, "_time"))
1761845136141:return(out)
1761845136142:}
1761845136143:# 4. Attach nearest HR and SBP
1761845136144:hr_data  <- nearest_match(labs, vitals, "HR")
1761845136145:sbp_data <- nearest_match(labs, vitals, "SBP")
1761845136146:labs_with_vitals <- cbind(labs, hr_data, sbp_data)
1761845136147:labs_with_vitals$hr_lag_minutes  <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$HR_time, units = "mins"))
1761845136147:labs_with_vitals$sbp_lag_minutes <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$SBP_time, units = "mins"))
1761845136149:# 5. Correlation per patient (CRP only) â€” robust version in base R
1761845136149:crp_data <- subset(labs_with_vitals, lab == "CRP")
1761845136151:# Split by patient_id
1761845136152:patients_list <- split(crp_data, crp_data$patient_id)
1761845136154:# Function to compute correlation safely
1761845136154:safe_cor <- function(df, col_x = "value", col_y = "nearest_HR") {
1761845136155:if (nrow(df) < 2) return(NA_real_)           # meno di 2 osservazioni -> NA
1761845136156:x <- df[[col_x]]
1761845136157:y <- df[[col_y]]
1761845136157:# keep only pairs non-NA
1761845136158:ok <- !is.na(x) & !is.na(y)
1761845136159:if (sum(ok) < 2) return(NA_real_)            # meno di 2 coppie valide -> NA
1761845136160:return(cor(x[ok], y[ok], use = "complete.obs"))
1761845136160:}
1761845136162:# Calcola correlazione CRP vs HR per ogni paziente
1761845136163:cor_crp_hr <- data.frame(
1761845136164:patient_id = names(patients_list),
1761845136165:correlation_CRP_HR = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_HR"),
1761845136166:row.names = NULL,
1761845136167:stringsAsFactors = FALSE
1761845136168:)
1761845136169:# Calcola correlazione CRP vs SBP per ogni paziente
1761845136170:cor_crp_sbp <- data.frame(
1761845136171:patient_id = names(patients_list),
1761845136172:correlation_CRP_SBP = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_SBP"),
1761845136173:row.names = NULL,
1761845136174:stringsAsFactors = FALSE
1761845136175:)
1761845136176:}
1761845136178:# ----------------------------------------------------------
1761845136179:# TASK 7 â€“ Compute coefficient of variation (CV)
1761845136179:# ----------------------------------------------------------
1761845136180:#' Extract peaks on chromosome and return top N by score
1761845136181:#'
1761845136181:#' Filters ATAC peaks by chromosome and genomic interval and returns
1761845136182:#' the top 50 by score â€” useful for quick locus-specific exploration.
1761845136183:#'
1761845136184:#' @param peaks_path Path to CSV file with columns:chr, start, end, peak_id, score
1761845136185:#' @param chr_sel selected chromosome string e.g.:"chr2"
1761845136186:#' @param start_min lower bound of range e.g.:2000000
1761845136186:#' @param start_max upper bound of range e.g.:4000000
1761845136187:#' @return none
1761845136188:#' @export
1761845136189:top_peaks_df <- function(peaks_path, chr_sel, start_min , start_max) {
1761845136190:peaks <- read.csv(peaks_path, stringsAsFactors = FALSE)
1761845136190:subset_peaks <- subset(peaks, chr == chr_sel & start >= start_min & start <= start_max)
1761845136191:subset_peaks <- subset_peaks[order(-subset_peaks$score), ]
1761845136192:top50_peaks <- head(subset_peaks, 50)
1761845136193:}
1761845136194:# ----------------------------------------------------------
1761845136195:# TASK 8 â€“ Identify most variable genes
1761845136195:# ----------------------------------------------------------
1761845136196:#' Compute per-condition gene stas and filter based on fold change.
1761845136197:#'
1761845136198:#' Calculates mean, median, and quartile statistics for each gene under
1761845136198:#' treated and control conditions, then filters genes where the treated
1761845136199:#' mean is at least twice the control mean (treated_mean â‰¥ 2 Ã— control_mean).
1761845136199:#'
1761845136200:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761845136201:#' @param meta_path Path to CSV file with columns: sample_id, condition, batch, patient ID, timepoint.
1761845136202:#' @return none
1761845136202:#' @export
1761845136203:gene_stats_filter_df <- function(counts_path, meta_path) {
1761845136204:counts <- read.csv(counts_path, stringsAsFactors = FALSE)
1761845136204:meta   <- read.csv(meta_path, stringsAsFactors = FALSE)
1761845136206:merged <- merge(counts, meta, by = "sample_id")
1761845136207:stats_by_gene_condition <- aggregate(count ~ gene + condition, data = merged,
1761845136208:FUN = function(x) c(mean = mean(x), median = median(x),
1761845136208:Q1 = quantile(x, 0.25, type = 2),
1761845136209:Q3 = quantile(x, 0.75, type = 2)))
1761845136210:stats_df <- data.frame(
1761845136211:gene = stats_by_gene_condition$gene,
1761845136212:condition = stats_by_gene_condition$condition,
1761845136212:mean_count = stats_by_gene_condition$count[, "mean"],
1761845136213:median_count = stats_by_gene_condition$count[, "median"],
1761845136213:Q1 = stats_by_gene_condition$count[, "Q1.25%"],
1761845136214:Q3 = stats_by_gene_condition$count[, "Q3.75%"]
1761845136215:)
1761845136216:treated <- subset(stats_df, condition == "treated")[, c("gene", "mean_count")]
1761845136217:control <- subset(stats_df, condition == "control")[, c("gene", "mean_count")]
1761845136217:names(treated)[2] <- "treated_mean"
1761845136218:names(control)[2] <- "control_mean"
1761845136219:means_wide <- merge(treated, control, by = "gene")
1761845136220:kept_genes <- subset(means_wide, treated_mean >= 2 * control_mean)
1761845136221:}
1761845136222:# ----------------------------------------------------------
1761845136223:# TASK 9 â€“ Compute correlation matrix across samples
1761845136223:# ----------------------------------------------------------
1761845136224:#' Convert wide counts to long and back, computing mean per condition
1761845136225:#'
1761845136225:#'Demonstrates data reshaping with \code{melt()} and \code{dcast()}.
1761845136226:#' Converts wide-format counts (one column per sample) to long format,
1761845136226:#' merges with metadata, computes mean per gene and condition,
1761845136227:#' and returns a condition-wide table again.
1761845136227:#'
1761845136228:#' @param counts_wide_path Path to CSV file with columns genes and samples
1761845136228:#' @return none
1761845136229:#' @export
1761845136230:wide_long_wide_df <- function(counts_path, meta_path) {
1761845136230:counts_wide <- read.csv(counts_path, stringsAsFactors = FALSE)
1761845136231:counts_long <- reshape(counts_wide, varying = names(counts_wide)[-1],
1761845136232:v.names = "count", timevar = "sample_id",
1761845136233:times = names(counts_wide)[-1], idvar = "gene",
1761845136233:direction = "long")
1761845136234:meta <- read.csv(meta_path, stringsAsFactors = FALSE)
1761845136235:merged <- merge(counts_long, meta, by = "sample_id")
1761845136236:totals_per_sample <- aggregate(count ~ sample_id, data = merged, sum)
1761845136237:names(totals_per_sample)[2] <- "total_count"
1761845136238:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761845136239:gene_condition_means <- aggregate(count ~ gene + condition, data = merged, mean)
1761845136240:counts_condition_wide <- reshape(gene_condition_means,
1761845136240:timevar = "condition", idvar = "gene",
1761845136241:direction = "wide")
1761845136242:}
1761845136243:# ----------------------------------------------------------
1761845136243:# TASK 10 â€“ PCA on normalized data
1761845136244:# ----------------------------------------------------------
1761845136244:#' Map ATAC-seq peaks to genes using genomic overlaps
1761845136245:#'
1761845136246:#' Uses \code{foverlaps()} to detect overlaps between peak intervals
1761845136246:#' and gene coordinates, computes overlap lengths, and summarizes
1761845136247:#' peaks per gene and total overlap length. Returns top 20 genes
1761845136247:#' with the most total overlapping base pairs.
1761845136248:#'
1761845136248:#' @param peaks_path Path to CSV file with columns: chr, start, end, peak_id, score
1761845136249:#' @param genes_path Path to CSV file with columns: chr, start, end, gene
1761845136249:#' @return none
1761845136250:#' @export
1761845136250:atac_to_gene_df <- function(peaks_path, genes_path) {
1761845136251:peaks <- read.csv(peaks_path, stringsAsFactors = FALSE)
1761845136251:genes <- read.csv(genes_path, stringsAsFactors = FALSE)
1761845136252:# overlap calcolato â€œa manoâ€
1761845136253:overlaps_list <- lapply(1:nrow(peaks), function(i) {
1761845136254:p <- peaks[i, ]
1761845136254:gsub <- subset(genes, chr == p$chr & start <= p$end & end >= p$start)
1761845136255:if (nrow(gsub) == 0) return(NULL)
1761845136255:gsub$overlap_bp <- pmin(p$end, gsub$end) - pmax(p$start, gsub$start)
1761845136256:gsub <- gsub[gsub$overlap_bp > 0, ]
1761845136257:gsub$peak_id <- i
1761845136257:gsub
1761845136258:})
1761845136259:overlaps <- do.call(rbind, overlaps_list)
1761845136260:peaks_per_gene <- aggregate(overlap_bp ~ gene, data = overlaps, FUN = length)
1761845136261:names(peaks_per_gene)[2] <- "num_peaks"
1761845136262:overlap_sum_per_gene <- aggregate(overlap_bp ~ gene, data = overlaps, sum)
1761845136263:names(overlap_sum_per_gene)[2] <- "total_overlap_bp"
1761845136264:top20_genes <- head(overlap_sum_per_gene[order(-overlap_sum_per_gene$total_overlap_bp), ], 20)
1761845136265:}
1761845136266:# ----------------------------------------------------------
1761845136267:# TASK 11 â€“ Plot gene expression distribution
1761845136268:# ----------------------------------------------------------
1761845136268:#' Map genetic variants to genes and count HIGH-impact variants
1761845136269:#'
1761845136269:#' Performs overlap join between variant coordinates and gene annotations,
1761845136270:#' counts variants per gene, and identifies genes with HIGH-impact variants.
1761845136270:#'
1761845136271:#' @param variants_path  Path to CSV file with columns: sample_id, chr, pos, ref, alt, impact
1761845136271:#' @param genes_path  Path to CSV file with columns: chr, start, end, gene
1761845136272:#' @return none
1761845136272:#' @export
1761845136273:variants_to_genes_df <- function(variants_path, genes_path) {
1761845136274:variants <- read.csv(variants_path)
1761845136275:genes    <- read.csv(genes_path)
1761845136276:# Creo intervalli 1-bp per le varianti -----------------------------------
1761845136277:# Ogni variante Ã¨ un punto, quindi creo due colonne identiche (start, end)
1761845136277:variants$start <- variants$pos
1761845136278:variants$end   <- variants$pos
1761845136279:# 3 Trovo le varianti che si sovrappongono a ciascun gene ------------------
1761845136280:# (equivalente a foverlaps)
1761845136281:# Facciamo un ciclo semplice: per ogni variante controlliamo se rientra nellâ€™intervallo del gene
1761845136281:# Questo Ã¨ molto meno efficiente, ma chiaro e comprensibile
1761845136282:overlaps_list <- list()
1761845136283:for (i in seq_len(nrow(variants))) {
1761845136284:var_chr   <- variants$chr[i]
1761845136284:var_start <- variants$start[i]
1761845136285:var_end   <- variants$end[i]
1761845136286:# Trova i geni sullo stesso cromosoma che si sovrappongono a quella variante?????
1761845136287:overlapping_genes <- subset(genes,
1761845136287:chr == var_chr &
1761845136288:start <= var_end &
1761845136289:end >= var_start)
1761845136290:# Se ci sono geni che si sovrappongono, li aggiungo alla lista
1761845136290:if (nrow(overlapping_genes) > 0) {
1761845136291:tmp <- data.frame(
1761845136292:sample_id = variants$sample_id[i],
1761845136292:gene = overlapping_genes$gene,
1761845136293:chr = var_chr,
1761845136294:pos = var_start,
1761845136294:impact = variants$impact[i],
1761845136295:stringsAsFactors = FALSE
1761845136296:)
1761845136296:overlaps_list[[length(overlaps_list) + 1]] <- tmp
1761845136297:}
1761845136298:}
1761845136299:# Combino tutti i risultati in un unico data.frame
1761845136300:if (length(overlaps_list) > 0) {
1761845136300:overlaps <- do.call(rbind, overlaps_list)
1761845136301:} else {
1761845136302:overlaps <- data.frame()
1761845136303:}
1761845136304:# Normalizzo la colonna impact a maiuscolo --------------------------------
1761845136305:if (nrow(overlaps) > 0) {
1761845136306:overlaps$impact_upper <- toupper(overlaps$impact)
1761845136307:}
1761845136308:# Filtro solo le varianti di alto impatto ---------------------------------
1761845136309:high_overlaps <- subset(overlaps, impact_upper == "HIGH")
1761845136310:# Conteggio delle varianti HIGH per gene e per sample ---------------------
1761845136311:if (nrow(high_overlaps) > 0) {
1761845136311:high_counts_by_gene_sample <- aggregate(
1761845136312:x = list(high_variant_count = high_overlaps$impact_upper),
1761845136313:by = list(gene = high_overlaps$gene, sample_id = high_overlaps$sample_id),
1761845136314:FUN = length
1761845136314:)
1761845136315:} else {
1761845136316:high_counts_by_gene_sample <- data.frame()
1761845136317:}
1761845136318:# Conteggio totale delle varianti HIGH per gene --------------------------
1761845136319:if (nrow(high_overlaps) > 0) {
1761845136320:high_counts_by_gene <- aggregate(
1761845136321:x = list(total_high_variants = high_overlaps$impact_upper),
1761845136322:by = list(gene = high_overlaps$gene),
1761845136322:FUN = length
1761845136323:)
1761845136324:# Ordina in modo decrescente
1761845136325:high_counts_by_gene <- high_counts_by_gene[order(-high_counts_by_gene$total_high_variants), ]
1761845136326:# Geni con almeno una variante HIGH
1761845136327:genes_with_high <- unique(high_counts_by_gene$gene)
1761845136328:} else {
1761845136328:high_counts_by_gene <- data.frame()
1761845136329:genes_with_high <- character(0)
1761845136330:}
1761845136331:# Salvo i risultati su file CSV ------------------------------------------
1761845136332:write.csv(high_counts_by_gene_sample, "project_oct25/high_variants_by_gene_sample.csv", row.names = FALSE)
1761845136333:write.csv(high_counts_by_gene, "project_oct25/high_variants_by_gene_total.csv", row.names = FALSE)
1761845136333:write.csv(data.frame(gene = genes_with_high), "project_oct25/genes_with_high_variants.csv", row.names = FALSE)
1761845136334:}
1761845136336:# ----------------------------------------------------------
1761845136336:# TASK 12 â€“ Compute summary statistics
1761845136337:# ----------------------------------------------------------
1761845136337:#' Combine cohorts safely and compute variability summaries
1761845136338:#'
1761845136338:#' This function merges two cohort-level sample metadata tables
1761845136339:#' and joins them to a long-format RNA-seq counts table to perform a per-cohort, per-condition
1761845136340:#' expression summary of the most 100 variable genes.
1761845136341:#'
1761845136341:#' @param cohortA_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761845136342:#' @param cohortB_path Path to CSV file with columns: sample_id, condition, batch, patient_id, timepoint, cohort
1761845136342:#' @param counts_path Path to CSV file with columns: gene, sample_id, count.
1761845136344:#' @return none
1761845136344:#' @export
1761845136345:combine_cohorts_df <- function(cohortA_path, cohortB_path, counts_path) {
1761845136345:cohortA <- read.csv(cohortA_path, stringsAsFactors = FALSE)
1761845136346:cohortB <- read.csv(cohortB_path, stringsAsFactors = FALSE)
1761845136347:counts  <- read.csv(counts_path, stringsAsFactors = FALSE)
1761845136348:cohortA$cohort <- "A"
1761845136348:cohortB$cohort <- "B"
1761845136349:combined_cohorts <- rbind(cohortA, cohortB)
1761845136350:combined_cohorts <- combined_cohorts[order(combined_cohorts$cohort,
1761845136351:combined_cohorts$condition,
1761845136351:combined_cohorts$sample_id), ]
1761845136352:merged <- merge(counts, combined_cohorts, by = "sample_id", all.x = TRUE)
1761845136353:gene_variance <- aggregate(count ~ gene, data = merged, FUN = var, na.rm = TRUE)
1761845136354:names(gene_variance)[2] <- "variance"
1761845136355:top100_genes <- head(gene_variance[order(-gene_variance$variance), "gene"], 100)
1761845136356:top100_data <- subset(merged, gene %in% top100_genes)
1761845136357:mean_counts <- aggregate(count ~ gene + cohort + condition,
1761845136358:data = top100_data, FUN = mean, na.rm = TRUE)
1761845136358:names(mean_counts)[4] <- "mean_count"
1761845136359:}
1761845136361:# ----------------------------------------------------------
1761845136362:# FINAL REVISION TASKS (1.1 -> 5.1)
1761845136362:# ----------------------------------------------------------
1761845136364:#TASK 1
1761845136364:#' Combine integration and clustering data
1761845136365:#'
1761845136366:#' Reads and merges integration and clustering tables by cell ID, ensuring consistent ID formatting.
1761845136367:#' @param integration_path Path to CSV file with columns: cell, integration_cluster
1761845136368:#' @param clustering_path Path to CSV file with columns: cell, cell_type, sample_type
1761845136368:#' @return none
1761845136369:#' @export
1761845136370:final_revision_df <- function(integration_path, clustering_path) {
1761845136370:# Funzione di normalizzazione ID cellule
1761845136371:normalize_cell_id <- function(x) {
1761845136372:x <- as.character(x)
1761845136372:x <- trimws(x)
1761845136373:x <- gsub("_X_", "_", x)
1761845136373:x <- gsub("_Y_", "_", x)
1761845136374:x <- gsub("_\\.", ".", x)
1761845136374:return(x)
1761845136375:}
1761845136376:# ==========================================
1761845136377:# TASK 1.1
1761845136377:# ==========================================
1761845136378:# Leggi i file in data.frame
1761845136379:integration_df <- read.csv(integration_path)
1761845136379:clustering_df  <- read.csv(clustering_path)
1761845136380:# Normalizza gli ID
1761845136381:integration_df$cell_clean <- normalize_cell_id(integration_df$cell)
1761845136382:clustering_df$cell_clean  <- normalize_cell_id(clustering_df$cell)
1761845136383:# Join sulle cellule
1761845136383:combined_df <- merge(integration_df, clustering_df, by = "cell_clean", all = FALSE)
1761845136384:# Salva file Task 1
1761845136385:write.csv(combined_df, "Outputs/combined_cell_cluster_celltype.csv", row.names = FALSE)
1761845136386:# ==========================================
1761845136387:# TASK 2.1
1761845136387:# ==========================================
1761845136388:counts_cluster_celltype <- aggregate(cell_clean ~ integration_cluster + cell_type,
1761845136389:data = combined_df, FUN = length)
1761845136390:colnames(counts_cluster_celltype)[3] <- "cell_count"
1761845136391:write.csv(counts_cluster_celltype, "Outputs/counts_per_cluster_celltype.csv", row.names = FALSE)
1761845136392:# ==========================================
1761845136392:# TASK 3.1
1761845136393:# ==========================================
1761845136395:# Conta per cluster, cell_type, sample_type
1761845136395:tab_ct_st <- aggregate(cell_clean ~ integration_cluster + cell_type + sample_type,
1761845136396:data = combined_df, FUN = length)
1761845136397:colnames(tab_ct_st)[4] <- "cell_count"
1761845136399:# Totale per cluster
1761845136400:totals_cluster <- aggregate(cell_clean ~ integration_cluster,
1761845136400:data = combined_df, FUN = length)
1761845136401:colnames(totals_cluster)[2] <- "cluster_total_cells"
1761845136403:# Merge per aggiungere totale cluster
1761845136403:tab_ct_st <- merge(tab_ct_st, totals_cluster, by = "integration_cluster", all.x = TRUE)
1761845136405:# Percentuale dentro cluster
1761845136406:tab_ct_st$pct_within_cluster <- (tab_ct_st$cell_count / tab_ct_st$cluster_total_cells) * 100
1761845136407:# Totale per (cluster, cell_type)
1761845136408:totals_cluster_celltype <- aggregate(cell_clean ~ integration_cluster + cell_type,
1761845136409:data = combined_df, FUN = length)
1761845136410:colnames(totals_cluster_celltype)[3] <- "cluster_celltype_total"
1761845136411:# Merge + percentuale sample_type dentro cell_type del cluster
1761845136412:tab_ct_st <- merge(tab_ct_st, totals_cluster_celltype,
1761845136413:by = c("integration_cluster", "cell_type"), all.x = TRUE)
1761845136414:tab_ct_st$pct_within_cluster_celltype <- (tab_ct_st$cell_count / tab_ct_st$cluster_celltype_total) * 100
1761845136416:# Salva Task 3
1761845136421:write.csv(tab_ct_st, "Outputs/summary_cluster_celltype_sampletype.csv", row.names = FALSE)
1761845136425:# ==========================================
1761845136426:# TASK 4.1
1761845136427:# ==========================================
1761845136428:plot_data <- as.data.frame(table(combined_df$integration_cluster,
1761845136429:combined_df$cell_type,
1761845136430:combined_df$sample_type))
1761845136431:colnames(plot_data) <- c("cluster", "cell_type", "tissue", "count")
1761845136433:# Totale per cluster e tessuto
1761845136433:totals <- aggregate(count ~ cluster + tissue, data = plot_data, sum)
1761845136434:colnames(totals)[3] <- "total"
1761845136436:# Merge + percentuali
1761845136436:plot_data <- merge(plot_data, totals, by = c("cluster", "tissue"))
1761845136437:plot_data$percent <- (plot_data$count / plot_data$total) * 100
1761845136439:# Plot
1761845136439:plot4_1_df <- ggplot(plot_data, aes(x = cluster, y = percent, fill = cell_type)) +
1761845136440:geom_bar(stat = "identity") +
1761845136441:facet_wrap(~ tissue) +
1761845136442:labs(title = "Distribution of cell types in clusters (Normal vs Tumor)",
1761845136443:x = "Integration Cluster",
1761845136443:y = "Cell Percentage (%)") +
1761845136444:theme_minimal()
1761845136446:ggsave( "Outputs/plot4_1_df.jpeg", plot = plot4_1_df, width = 3000, height = 1500, units = "px")
1761845136448:# ==========================================
1761845136449:# TASK 5.1
1761845136450:# ==========================================
1761845136451:# Conta celle
1761845136452:counts <- as.data.frame(table(combined_df$integration_cluster,
1761845136453:combined_df$cell_type,
1761845136453:combined_df$sample_type))
1761845136454:colnames(counts) = c("cluster", "cell_type", "tissue", "count")
1761845136456:# Totale per cluster e tessuto
1761845136457:totals <- aggregate(count ~ cluster + tissue, data = counts, sum)
1761845136457:colnames(totals)[3] <- "total"
1761845136459:# Merge e calcolo % normalizzata
1761845136460:counts_norm <- merge(counts, totals, by = c("cluster", "tissue"))
1761845136461:counts_norm$percent <- round((counts_norm$count / counts_norm$total) * 100, 2)
1761845136462:# Salva Task 5
1761845136464:write.csv(counts_norm, "Outputs/normalized_percent_cluster_celltype_tissue.csv", row.names = FALSE)
1761845136466:}
1761845204140:#Goal: Filter, summarize, and group bulk counts. Data: bulk_counts_long.csv, sample_metadata.csv Tasks:
1761845204145:#â€¢ Keep counts for samples in condition == "treated" and genes starting with "GENE_00".
1761845204146:#â€¢ Compute mean and median count by gene (valore centrale).
1761845204149:#â€¢ Join sample metadata and compute per-condition mean counts by gene in one pipeline.
1761845204152:library(data.table)
1761845204319:# 1. Import
1761845204320:bulk_counts <- fread("project_oct25/bulk_counts_long.csv")
1761845204330:sample_meta   <- fread("project_oct25/sample_metadata.csv")
1761845204332:# 2. Join counts + metadata by sample_id
1761845204333:#imposta sample_id come chiave sull'oggetto counts e meta quindi counts viene ordinato per sample_id
1761845204334:#effettua una modifica in place (non crea una copia)
1761845204334:#questo permette join molto piÃ¹ rapidi
1761845204335:setkey(bulk_counts, sample_id) #setkey ordina la tabella e rende piÃ¹ veloce l'unione di tabelle
1761845204338:setkey(sample_meta, sample_id)
1761845204340:join_data <- bulk_counts[sample_meta, nomatch = 0]
1761845204383:#In data.table la forma X[i] puÃ² essere usata per i join:
1761845204384:#X = tabella da cui prendi i dati (qui counts)
1761845204384:#i = tabella che serve come query/indice (qui meta)
1761845204385:#Quando ci sono chiavi compatibili (sample_id), counts[meta] interpreta meta come la tabella di lookup
1761845204386:#e per ciascuna riga di meta estrae le righe corrispondenti da counts
1761845204387:#nomatch = 0 significa: escludi le righe di meta che non trovano corrispondenza in counts.
1761845204387:#Questo equivale a un inner join (solo righe with match).
1761845204389:# 3. Filter for treated samples and GENE_00* genes
1761845204390:filtered_data <- join_data[condition == "treated" & grepl("^GENE_00", gene)]
1761845204395:#filtrare stringhe in base a un pattern (cioÃ¨ una â€œregolaâ€ di testo).
1761845204396:#Quindi grepl("^GENE_00", gene) restituisce:
1761845204397:#TRUE per tutti i geni che iniziano con GENE_00
1761845204397:#FALSE per tutti gli altri.
1761845204399:# 4. Compute mean and median per gene
1761845204399:gene_mean_median <- filtered_data[, .(
1761845204400:mean_count   = mean(count),
1761845204401:median_count = median(count)
1761845204401:), by = gene]
1761845204411:# Punto 5 corretto: join + per-condition mean by gene (una pipeline)
1761845204412:# Calcola la media dei conteggi per ogni combinazione (gene, condition)
1761845204413:# tutto in una singola pipeline: unisco metadata e counts e poi raggruppo
1761845204414:gene_condition_means <- bulk_counts[
1761845204415:sample_meta,                # uso sample_meta come "i" (lookup)
1761845204416:on = "sample_id"            # join su sample_id (non serve setkey se usi on=)
1761845204417:][ , .(
1761845204417:mean_count = mean(count)   # media dei conteggi (ignora NA se ci sono)
1761845204418:), by = .(gene, condition) ]               # raggruppa per gene e per condition
1761845204436:#CON FUNCTION:
1761845204447:result <- bulk_counts_summary_dt("project_oct25/bulk_counts_long.csv","project_oct25/sample_metadata.csv")
1761845247244:# ==========================================================
1761845247248:# TASK 6 â€“ data.frame version
1761845247251:# ==========================================================
1761845247255:# 1. Import
1761845247256:labs   <- read.csv("project_oct25/clinical_labs.csv")
1761845247262:vitals <- read.csv("project_oct25/vitals_time_series.csv")
1761845247270:# 2. Convert to POSIXct
1761845247272:labs$time_iso   <- as.POSIXct(labs$time_iso)
1761845247276:vitals$time_iso <- as.POSIXct(vitals$time_iso)
1761845247281:# 3. Join nearest HR/SBP manually (loop-based)
1761845247282:nearest_match <- function(lab_df, vitals_df, vital_type) {
1761845247283:vitals_sub <- vitals_df[vitals_df$vital == vital_type, ]
1761845247284:results <- list()
1761845247285:for (i in seq_len(nrow(lab_df))) {
1761845247286:pid <- lab_df$patient_id[i]
1761845247287:time <- lab_df$time_iso[i]
1761845247288:v_sub <- vitals_sub[vitals_sub$patient_id == pid, ]
1761845247288:if (nrow(v_sub) > 0) {
1761845247290:idx <- which.min(abs(difftime(v_sub$time_iso, time, units = "mins")))
1761845247291:results[[i]] <- v_sub[idx, c("value", "time_iso")]
1761845247292:} else {
1761845247293:results[[i]] <- data.frame(value = NA, time_iso = NA)
1761845247293:}
1761845247294:}
1761845247295:out <- do.call(rbind, results)
1761845247296:names(out) <- c(paste0("nearest_", vital_type), paste0(vital_type, "_time"))
1761845247297:return(out)
1761845247297:}
1761845247299:# 4. Attach nearest HR and SBP
1761845247300:hr_data  <- nearest_match(labs, vitals, "HR")
1761845247484:sbp_data <- nearest_match(labs, vitals, "SBP")
1761845247645:labs_with_vitals <- cbind(labs, hr_data, sbp_data)
1761845247647:labs_with_vitals$hr_lag_minutes  <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$HR_time, units = "mins"))
1761845247648:labs_with_vitals$sbp_lag_minutes <- as.numeric(difftime(labs_with_vitals$time_iso, labs_with_vitals$SBP_time, units = "mins"))
1761845247649:# 5. Correlation per patient (CRP only) â€” robust version in base R
1761845247650:crp_data <- subset(labs_with_vitals, lab == "CRP")
1761845247652:# Split by patient_id
1761845247653:patients_list <- split(crp_data, crp_data$patient_id)
1761845247659:# Function to compute correlation safely
1761845247660:safe_cor <- function(df, col_x = "value", col_y = "nearest_HR") {
1761845247660:if (nrow(df) < 2) return(NA_real_)           # meno di 2 osservazioni -> NA
1761845247661:x <- df[[col_x]]
1761845247662:y <- df[[col_y]]
1761845247662:# keep only pairs non-NA
1761845247663:ok <- !is.na(x) & !is.na(y)
1761845247664:if (sum(ok) < 2) return(NA_real_)            # meno di 2 coppie valide -> NA
1761845247664:return(cor(x[ok], y[ok], use = "complete.obs"))
1761845247665:}
1761845247666:# Calcola correlazione CRP vs HR per ogni paziente
1761845247667:cor_crp_hr <- data.frame(
1761845247667:patient_id = names(patients_list),
1761845247668:correlation_CRP_HR = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_HR"),
1761845247668:row.names = NULL,
1761845247669:stringsAsFactors = FALSE
1761845247669:)
1761845247684:# Calcola correlazione CRP vs SBP per ogni paziente
1761845247685:cor_crp_sbp <- data.frame(
1761845247686:patient_id = names(patients_list),
1761845247687:correlation_CRP_SBP = sapply(patients_list, safe_cor, col_x = "value", col_y = "nearest_SBP"),
1761845247687:row.names = NULL,
1761845247688:stringsAsFactors = FALSE
1761845247688:)
1761845254363:# ==========================================================
1761845254369:# TASK 9 â€“ data.frame version
1761845254371:# ==========================================================
1761845254376:counts_wide <- read.csv("project_oct25/bulk_counts_wide.csv", stringsAsFactors = FALSE)
1761845254389:counts_long <- reshape(counts_wide, varying = names(counts_wide)[-1],
1761845254392:v.names = "count", timevar = "sample_id",
1761845254394:times = names(counts_wide)[-1], idvar = "gene",
1761845254399:direction = "long")
1761845254436:meta <- read.csv("project_oct25/sample_metadata.csv", stringsAsFactors = FALSE)
1761845254438:merged <- merge(counts_long, meta, by = "sample_id")
1761845254506:totals_per_sample <- aggregate(count ~ sample_id, data = merged, sum)
1761845254522:names(totals_per_sample)[2] <- "total_count"
1761845254524:merged <- merge(merged, totals_per_sample, by = "sample_id")
1761845254567:gene_condition_means <- aggregate(count ~ gene + condition, data = merged, mean)
1761845254610:counts_condition_wide <- reshape(gene_condition_means,
1761845254611:timevar = "condition", idvar = "gene",
1761845254612:direction = "wide")
1761845254624:cat("\n--- Tabella finale: media dei conteggi per gene e condizione ---\n")
1761845254625:print(head(counts_condition_wide, 10))
1761845262518:#Goal: Slice genomics windows efficiently. Data: atac_peaks.bed.csv
1761845262524:#Tasks:
1761845262527:#â€¢ Extract peaks on chr2 with start between 2 and 4 Mb.
1761845262529:#â€¢ Among those peaks, return the top 50 by score after setorder() (descending)
1761845262532:# Carico la libreria
1761845262534:library(data.table)
1761845262536:# Leggo il file dei picchi ATAC
1761845262537:peaks <- fread("project_oct25/atac_peaks.bed.csv")
1761845262586:# Filtro i picchi su chr2 e nella finestra 2â€“4 Mb
1761845262587:# Nota: 1 Mb = 1.000.000 basi
1761845262588:subset_peaks <- peaks[chr == "chr2" & start >= 2000000 & start <= 4000000]
1761845262592:#Ordino i picchi per punteggio decrescente
1761845262593:subset_peaks <- setorder(subset_peaks, -score)
1761845262599:#Prendo i primi 50 picchi
1761845262600:top50_peaks <- head(subset_peaks, 50)
1761845262602:result <- top_peaks_dt("project_oct25/atac_peaks.bed.csv","chr2", 2000000,4000000)
1761845297343:git status
1761845357276:git status
1761866281416:?ProjectAlessandra
1761866289781:library(ProjectAlessandra)
1761866291857:?ProjectAlessandra
1761866476543:?ProjectAlessandra
1761866482698:??ProjectAlessandra
1761866511404:?bulk_counts_summary_dt
1761866524994:devtools::document
1761866536595:?ProjectAlessandra
1761866593390:devtools::load_all()
1761866601935:devtools::document()
1761866605856:devtools::load_all()
1761866612371:devtools::install()
1761866639587:?ProjectAlessandra
1761866839877:vignette(ProjectAlessandra)
1761866861073:vignette("ProjectAlessandra")
1761867041748:library(ProjectAlessandra)
1761867051954:library(help = "ProjectAlessandra")
1761867072445:?ProjectAlessandra
1761867096402:ls("package:ProjectAlessandra")
1761867117522:ls("package:data.table")
1761867155565:help(package = "ProjectAlessandra")
1761867206127:help(package = "ProjectAlessandra")
1761867232722:?ProjectAlessandra
1761867245826:help(ProjectAlessandra)
1761867253698:help(package = "ProjectAlessandra")
1761867263848:?package = "ProjectAlessandra"
1761867274643:?help
1761867872650:render("workflow_analysis.Rmd", output_format = "html_document")
1761867889367:library(rmarkdown)
1761867891307:render("workflow_analysis.Rmd", output_format = "html_document")
1761867903489:render("vignettes/workflow_analysis.Rmd", output_format = "html_document")
1761867947576:?render
1761868044426:render("vignettes/workflow_analysis.Rmd", output_format = "html_document", knit_root_dir = "home/rstudio")
1761868118388:render(
1761868118390:"vignettes/workflow_analysis.Rmd",
1761868118392:output_format = "html_document",
1761868118393:knit_root_dir = "/home/rstudio"
1761868118394:)
1761868266387:?ProjectAlessandra
1761869122584:?ProjectAlessandra
1761869142430:help(projectAlessandra)
1761869156677:help("projectAlessandra")
1761869184998:library(ProjectAlessandra)
1761869205384:?ProjectAlessandra
1761869214685:devtools::document()
1761869221593:devtools::load_all()
1761869238988:devtools::install(ProjectAlessandra)
1761869248989:devtools::install()
1761869275590:?data.table
1761869290233:?ProjectAlessandra
1761869454615:help("ProjectAlessandra")
1761869463580:help(package = "ProjectAlessandra")
1761905280968:devtools::document()
1761905288077:devtools::load_all()
1761905297257:devtools::install
1761905314241:?ProjectAlessandra
1761905502338:devtools::document()
1761905536409:devtools::document()
1761905543129:devtools::load_all()
1761905550849:devtools::install()
1761905570575:?ProjectAlessandra
1761905613661:devtools::document()
1761905619067:devtools::load_all()
1761905625941:devtools::install()
1761905638762:?ProjectAlessandra
1761905734253:devtools::document()
1761905741049:devtools::load_all()
1761905745822:devtools::install()
1761905808609:remove.packages("ProjectAlessandra")
1761905820588:devtools::clean_dll()
1761905829842:devtools::document()
1761905831609:devtools::install(clean = TRUE)
1761905912186:remove.packages("ProjectAlessandra")
1761905924763:find.package("ProjectAlessandra")
1761905933865:devtools::document()
1761905948336:unlink("ProjectAlessandra.Rcheck", recursive = TRUE)
1761905948340:unlink("ProjectAlessandra_*.tar.gz")
1761905955328:devtools::install()
1761906027512:?ProjectAlessandra
1761906034910:remove.packages("ProjectAlessandra")
1761906035154:unlink("/usr/local/lib/R/site-library/ProjectAlessandra", recursive = TRUE)
1761906047874:unlink("~/.R", recursive = TRUE)
1761906047883:unlink("/tmp/Rtmp*", recursive = TRUE)
1761906062962:devtools::document()
1761906066829:devtools::install()
1761906085625:devtools::install()
1761906125908:tempdir()
1761906151774:unlink("/usr/local/lib/R/site-library/ProjectAlessandra", recursive = TRUE)
1761906151778:devtools::install(clean = TRUE)
1761906164387:devtools::install()
1761906183394:devtools::build()
1761906213675:dir.exists("/tmp")
1761906213679:file.access("/tmp", 2)
1761906227187:dir.create("~/tmp_R", showWarnings = FALSE)
1761906227196:Sys.setenv(TMPDIR = "~/tmp_R")
1761906227198:tempdir()
1761906244326:tempdir()
1761906310576:devtools::document()
1761906353861:getwd()
1761906353863:file.access(getwd(), 2)
1761906391986:unlink("man", recursive = TRUE)          # elimina help generati
1761906391996:unlink("NAMESPACE")                      # verrÃ  ricreato
1761906392000:unlink("ProjectAlessandra.Rcheck", recursive = TRUE)
1761906392001:unlink("ProjectAlessandra_*.tar.gz")     # eventuali build vecchi
1761906392002:unlink(tempdir(), recursive = TRUE, force = TRUE)
1761906392004:dir.create("~/tmp_R", showWarnings = FALSE)
1761906392005:Sys.setenv(TMPDIR = normalizePath("~/tmp_R"))
1761906404548:tempdir()
1761906468710:?bulk_counts_qc
1761906818588:devtools::document()
1761906839053:devtools::install()
1761906852767:devtools::loadall()
1761906857309:devtools::load_all()
1761906864863:devtools::install()
1761906899815:?bulk_counts_summary
1761906983519:roxygen2::roxygenise()
1761907001135:devtools::document
1761907006007:devtools::document()
1761907017110:2+2
1761907037424:getwd()
1761907108612:library(ProjectAlessandra)
1761907133688:?bulk_counts_summary_dt
1761907205926:library(ProjectAlessandra)
1761907216273:devtools::document()
1761907223916:devtools::load_all()
1761907229901:devtools::install()
1761907254760:library(ProjectAlessandra)
1761907259448:?ProjectAlessandra
1761907300705:?bulk_counts_summary_dt
1761923770019:?ProjectAlessandra
1761923778540:?bulk_counts_qc_df
1761923900847:?ProjectAlessandra
1761924337420:?ProjectAlessandra
1761924374686:desc::desc_get("Description")
1761925369120:tree -L 2
